<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-python3/sklearn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/08/python3/sklearn/" class="article-date">
  <time datetime="2018-09-08T01:03:50.000Z" itemprop="datePublished">2018-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python3/">python3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/08/python3/sklearn/">sklearn</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>sklearn机器学习包中的一些方法说明和使用</p>
<h2 id="1-1-train-test-split"><a href="#1-1-train-test-split" class="headerlink" title="1.1 train_test_split"></a>1.1 train_test_split</h2><p>使用scitkie-learn中的一个方法，可以随机生成测试集和训练集。<br>sklearn.model_selection.train_test_split(train_data, train_target, test_size, train_size, random_state)</p>
<ul>
<li>test_size 默认情况下为0.25,可以为浮点数或者int型，在一致train_size的时候，它就确定了</li>
<li>random_state 随机数种子，其实就是改组随机数的编号，在需要重复试验的时候，保证得到一组一样的随机数。比如每次都填1，其他参数设置一样的情况下得到的随机数组是一样的，但是如果填0或者不填，每次都会不一样。随机数的产生取决于中农资；随机数和种子之间的关系遵从以下两个原则：种子不同，产生不同的随机数；种子相同，即使实例不同也产生相同的随机数。</li>
</ul>
<p>返回值跟传入的数组有关，如果有x，y，返回的就是2<em>len(x,y) = 2</em>x = 4。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># train_test_split是从model_selection中导入的。</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X, y = np.arange(<span class="number">10</span>).reshape((<span class="number">5</span>, <span class="number">2</span>)), range(<span class="number">5</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=<span class="number">0.33</span>, random_state=<span class="number">42</span>)</span><br><span class="line">X</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1],
       [2, 3],
       [4, 5],
       [6, 7],
       [8, 9]])
</code></pre><h2 id="1-2-SVC"><a href="#1-2-SVC" class="headerlink" title="1.2 SVC()"></a>1.2 SVC()</h2><p>class sklearn.svm.SVC(C=1.0, kernel=’rbf’, degree=3, gamma=’auto’, coef0=0.0, shrinking=True, probability=False, tol=0.001, cache_size=200, class_weight=None, verbose=False, max_iter=-1, decision_function_shape=’ovr’, random_state=None)<br>官方文档：<br>c-支持向量分类：该实现是基于libsvm，拟合事件复杂度大于样本数量的平方，因此当样本数量大于10000的时候就不适用了。同时它的多类支持是通过一对一的方案解决的。<br><a href="http://scikit-learn.org/stable/modules/svm.html#svm-classification" target="_blank" rel="noopener">全面的支持向量机文档</a></p>
<ul>
<li>C 惩罚参数</li>
<li>kernel 内核函数，可以是linear  poly  rbf  sigmoid  precomputed 分别是线性核函数、多项式核函数（最常用的径向机核函数就是高斯核函数）、径向机核函数、神经元的非线性作用函数核函数、用户自定义核函数。</li>
<li>degree 当使用多项式核函数的时候，degree定义了该核函数的多项式次数。</li>
<li>gamma rbf  poly  sigmoid的核系数。【具体含义不清楚】</li>
<li>decision_function_shape   ovr就是one vs rest  一个类别与其他类别进行划分     ovo  one vs one类别两两之间进行划分，即使用二分类的方法模拟多分类的结果。</li>
</ul>
<p>还包括一些训练完成之后的方法，碧土score  predict   decision_function等比较简单，可以查看官方文档。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/08/python3/sklearn/" data-id="cjtinfppw001kxw777z4xuwn9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/matplotlib/">matplotlib</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithms/KnapsackProblems" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/03/Algorithms/KnapsackProblems/" class="article-date">
  <time datetime="2018-09-03T11:24:33.000Z" itemprop="datePublished">2018-09-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/03/Algorithms/KnapsackProblems/">KnapsackProblems</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>通过学习背包九讲这个文档，掌握动态规划题目的解决方法。</p>
<h1 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1 背包问题"></a>1 背包问题</h1><p>有N 件物品和一个容量为V 的背包。第i 件物品的费用（体积）是c[i]，价值是w[i]。<br>求解将哪些物品装入背包可使价值总和最大。这里每一件物品只能取一次</p>
<h2 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h2><p>根据子问题定义状态，找出状态转移方程。<br>子问题就是：第i件物品是否放入背包。如果不放，那么第i件物品放入背包中的总价值和第i-1件物品放入背包的总价值相当。如果放入背包，也就是求出第i-1件物品放入v-c[i]的背包中时的值与第i件物品的价值的和，得到的就是总价值。<br>f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}</p>
<p>核心代码如下：<br>以下代码中，注意i和j的起始遍历位置，从第1行和第1列开始，此时的1表示的就是物品的编号。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//traverse N goods</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=V;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j-C[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            f[i][j] = Math.max(f[i-<span class="number">1</span>][j],f[i-<span class="number">1</span>][j-C[i]]+W[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            f[i][j] = f[i-<span class="number">1</span>][j];   <span class="comment">//这行代码可以不要。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-2-初始化问题"><a href="#1-2-初始化问题" class="headerlink" title="1.2 初始化问题"></a>1.2 初始化问题</h2><p>已知有物品4件（N=4），背包容量V=10，每件物品的体积为5,4,6,3，每件物品的对应价值为10,40,30,50。<br>首先是关于初始化的问题，可以建立一个$(N+1)*(V+1)$的二维数组，增设第一行第一列是为了循环遍历的方便。一步步构建如下所示，初始时可以构建二维数组如下：  </p>
<table>
<thead>
<tr>
<th>V      N</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>得到的结果如下：</p>
<p>如果没有要求必须恰好装满背包，那么初始化的时候可以将二维数组全部初始化为0。若要求恰好装满背包，那么在初始化的时候除了第一行和第一列为0，其余均为无穷大。此时表最终的结果如下： </p>
<table>
<thead>
<tr>
<th>V      N</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>inf</td>
<td>inf</td>
<td>inf</td>
<td>inf</td>
<td>10</td>
<td>10</td>
<td>10</td>
<td>10</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>inf</td>
<td>inf</td>
<td>inf</td>
<td>40</td>
<td>10</td>
<td>10</td>
<td>10</td>
<td>10</td>
<td>50</td>
<td>50</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>inf</td>
<td>inf</td>
<td>inf</td>
<td>inf</td>
<td>inf</td>
<td>30</td>
<td>10</td>
<td>10</td>
<td>50</td>
<td>70</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>inf</td>
<td>inf</td>
<td>50</td>
<td>inf</td>
<td>inf</td>
<td>30</td>
<td>10</td>
<td>10</td>
<td>80</td>
<td>70</td>
</tr>
</tbody>
</table>
<p>需要注意的是，此时上述的核心代码中就要有一定的调整，调整如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//traverse N goods</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=V;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j-C[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            f[i][j] = Math.max(f[i-<span class="number">1</span>][j],f[i-<span class="number">1</span>][j-C[i]]+W[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//这里的语句需要删掉，否则初始化为负无穷大就没有了意义。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-3-被选择的物品"><a href="#1-3-被选择的物品" class="headerlink" title="1.3 被选择的物品"></a>1.3 被选择的物品</h2><p>当求解出最大价值的时候，如何求出所选择的的物品？根据状态转移方程可知，当f[i-1][j] = f[i][j]的时候，表示i没有放入背包，否则表示放入背包，此时减去该背包的体积，然后再判断该体积下的情况，直到第一件物品。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = N;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[i-<span class="number">1</span>][V] != f[i][V])&#123;</span><br><span class="line">        System.out.print(i+<span class="string">"  "</span>);</span><br><span class="line">        V -= C[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-4-空间优化"><a href="#1-4-空间优化" class="headerlink" title="1.4 空间优化"></a>1.4 空间优化</h2><p>每一次的f[i][v]的值只与f[i-1][v]的值有关，因此可以修改为一维数组，f[v]表示将前i个物品装入容量为v的背包时的最大价值。主要是注意遍历的时候，第二个是倒序，此时表示每一次循环的时候，上一次保存的f[v]还没有发生变化，从而说明一件物品被使用了一次。如果不是倒序还是使用正序，此时会发现可以重复选择物品。<br>下面代码中打印输出了每一次循环的时候f[v]的值。使用一维数组实现，从而在空间上进行了优化。如果要实现恰好装满背包，那么初始化的时候，f[0]为0，其余初始化为无穷大。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=C[i])&#123;</span><br><span class="line">            f[j] = Math.max(f[j], f[j-C[i]]+W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">        System.out.print(f[j]+<span class="string">"  "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-5-使用二维数组解决背包问题"><a href="#1-5-使用二维数组解决背包问题" class="headerlink" title="1.5 使用二维数组解决背包问题"></a>1.5 使用二维数组解决背包问题</h2><p>代码如下，注意其中两种的同的初始化。对于恰好装满背包问题，初始化数组的时候可以这样理解：初始化数据也就是初始化背包状态，即没有任何物品装入的时候的背包状态。如果要求背包恰好装满，那么最开始的时候只有背包容量为0的时候才有可能被价值为0的nothing恰好装满（因为背包的初始状态时什么也没装），如果容量大于1，那么此时因为背包什么也没装，则没有合法的解，属于未定义状态，可以初始化为$\inf$<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0-1 knapsack problem: two-dimensional array and one-dimensional array are used to resolve this problem</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack_2_array</span><span class="params">(N, V, C, W)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param N: the number of goods</span></span><br><span class="line"><span class="string">    :param V: the total volume of goods</span></span><br><span class="line"><span class="string">    :param C: the volume of each goods  type-list</span></span><br><span class="line"><span class="string">    :param W: the weight of each goods type-list</span></span><br><span class="line"><span class="string">    :return: f[N][V]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># initialization</span></span><br><span class="line">    <span class="comment"># f = np.zeros((N+1, V+1))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># another initialization for just full of knapsack</span></span><br><span class="line">    f = np.zeros((N+<span class="number">1</span>, V+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                f[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f[i][j] = float(<span class="string">'-inf'</span>)</span><br><span class="line">    print(f)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># repeat</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, V+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j-C[i]&gt;=<span class="number">0</span>:</span><br><span class="line">                f[i][j] = max(f[i<span class="number">-1</span>][j], f[i<span class="number">-1</span>][j-C[i]]+W[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_choosed_goods_2_array</span><span class="params">(N, V, C, W, f)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> f[i][V] == f[i<span class="number">-1</span>][V]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            V = V-C[i]</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    N = <span class="number">5</span></span><br><span class="line">    V = <span class="number">10</span></span><br><span class="line">    C = [<span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    W = [<span class="number">0</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>]</span><br><span class="line">    f1 = knapsack_2_array(N, V, C, W)</span><br><span class="line">    print(f1)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">恰好装满时的初始化结果和运行结果</span><br><span class="line">[[  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]]</span><br><span class="line">[[  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf   8. -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf  10. -inf   8. -inf -inf -inf  18.]</span><br><span class="line"> [  0. -inf -inf -inf  10. -inf   8. -inf  14. -inf  18.]</span><br><span class="line"> [  0. -inf   5. -inf  10. -inf  15. -inf  14. -inf  19.]</span><br><span class="line"> [  0. -inf   5.   5.  10.  10.  15.  15.  14.  20.  19.]]</span><br><span class="line"> 被选择物品 4 3 2</span><br><span class="line"></span><br><span class="line"> 没有要求恰好装满时的运行结果</span><br><span class="line">[[ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]</span><br><span class="line"> [ 0.  0.  0.  0.  0.  0.  8.  8.  8.  8.  8.]</span><br><span class="line"> [ 0.  0.  0.  0. 10. 10. 10. 10. 10. 10. 18.]</span><br><span class="line"> [ 0.  0.  0.  0. 10. 10. 10. 10. 14. 14. 18.]</span><br><span class="line"> [ 0.  0.  5.  5. 10. 10. 15. 15. 15. 15. 19.]</span><br><span class="line"> [ 0.  0.  5.  5. 10. 10. 15. 15. 15. 20. 20.]]</span><br><span class="line"></span><br><span class="line"> 输出被选择的物品</span><br><span class="line">5 4 2</span><br></pre></td></tr></table></figure>
<h2 id="1-6-使用一维数组解决问题"><a href="#1-6-使用一维数组解决问题" class="headerlink" title="1.6 使用一维数组解决问题"></a>1.6 使用一维数组解决问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack_1_array</span><span class="params">(N, V, C, W)</span>:</span></span><br><span class="line">    <span class="comment"># initialization</span></span><br><span class="line">    f = np.zeros(V+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialization for just full of knapsack</span></span><br><span class="line">    <span class="comment"># f = np.zeros(V+1)</span></span><br><span class="line">    <span class="comment"># for i in range(V+1):</span></span><br><span class="line">    <span class="comment">#     if i == 0:</span></span><br><span class="line">    <span class="comment">#         f[i] = 0</span></span><br><span class="line">    <span class="comment">#     else:</span></span><br><span class="line">    <span class="comment">#         f[i] = float('-inf')</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Output intermediate process result"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> j-C[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                f[j] = max(f[j], f[j-C[i]]+W[i])</span><br><span class="line">        print(f)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Output the final result"</span>)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_choosed_goods_1_array</span><span class="params">(N, V, C, W, f)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> f[V] == f[V-C[i]]+W[i]:</span><br><span class="line">            V = V-C[i]</span><br><span class="line">            print(i)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输出结果</span><br><span class="line">[  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line">Output intermediate process result</span><br><span class="line">[  0. -inf -inf -inf -inf -inf   8. -inf -inf -inf -inf]</span><br><span class="line">[  0. -inf -inf -inf  10. -inf   8. -inf -inf -inf  18.]</span><br><span class="line">[  0. -inf -inf -inf  10. -inf   8. -inf  14. -inf  18.]</span><br><span class="line">[  0. -inf   5. -inf  10. -inf  15. -inf  14. -inf  19.]</span><br><span class="line">[  0. -inf   5.   5.  10.  10.  15.  15.  14.  20.  19.]</span><br><span class="line">Output the final result</span><br><span class="line">[  0. -inf   5.   5.  10.  10.  15.  15.  14.  20.  19.]</span><br><span class="line">4 3 2</span><br><span class="line"></span><br><span class="line">没有要求恰好装满的时候</span><br><span class="line">Output intermediate process result</span><br><span class="line">[0. 0. 0. 0. 0. 0. 8. 8. 8. 8. 8.]</span><br><span class="line">[ 0.  0.  0.  0. 10. 10. 10. 10. 10. 10. 18.]</span><br><span class="line">[ 0.  0.  0.  0. 10. 10. 10. 10. 14. 14. 18.]</span><br><span class="line">[ 0.  0.  5.  5. 10. 10. 15. 15. 15. 15. 19.]</span><br><span class="line">[ 0.  0.  5.  5. 10. 10. 15. 15. 15. 20. 20.]</span><br><span class="line">Output the final result</span><br><span class="line">[ 0.  0.  5.  5. 10. 10. 15. 15. 15. 20. 20.]</span><br><span class="line"></span><br><span class="line">选择的物品</span><br><span class="line">5 4 2</span><br></pre></td></tr></table></figure>
<p>关于上面在j遍历的使用使用逆序的原因，下面举一个例子：如果按照j顺序遍历，当i=1,j=1,2的时候，f[1]=f[2] = 0;当j=3的时候，f[3] = max(f[3], f[3-3]+w[1])= max(0,4) = 4;当j=4,5的时候，f[4]=[5] = 4。但是当j=6的时候，有f[6] = max(f[6], f[6-3]+w[1]) = max(0, 8)。这个8其实是因为第一件物品取了两次得到的，这显然不符合01背包问题（每件物品只能取一次）</p>
<p>在输出结果的时候，注意遍历的方向，N是从最大值向最小值遍历，因为所得数组的最后一项内容是要求解的结果，所以需要从后向前遍历</p>
<h1 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2 完全背包问题"></a>2 完全背包问题</h1><p>与0-1背包问题的差别就是每一个物品可以重复多次放入，因此子问题就相应的需要改变，针对第i个物品，不是放入背包或者不放入背包，而应该是放入0次，或者多次。因此状态转移方程需要进行修改如下:</p>
<p>$$<br>f[i][v]=max{f[i-1][v-k\times{c[i]}]+k\times{w[i]}|0&lt;=k\times{c[i]}&lt;=v}<br>$$<br>k值表示放入的次数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMaxWorth</span><span class="params">(amount, total_capacity, volumes, worths)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        amount: the quantity of things  type-int</span></span><br><span class="line"><span class="string">        total_capacity: the volume of backpack  type-int</span></span><br><span class="line"><span class="string">        volumes: the volume of each thing  type-list</span></span><br><span class="line"><span class="string">        worths: the worth of each thing    type-list</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># create a amount*total_capacity array and initialization</span></span><br><span class="line">    f = np.zeros((amount+<span class="number">1</span>,total_capacity+<span class="number">1</span>), dtype=int)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># repeat</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,amount+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,total_capacity+<span class="number">1</span>):</span><br><span class="line">            temp = []</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> k*volumes[i] &lt;= j :</span><br><span class="line">                temp.append(f[i<span class="number">-1</span>][j-k*volumes[i]]+k*worths[i])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            f[i][j] = max(temp)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">amount = <span class="number">4</span></span><br><span class="line">total_capacity=<span class="number">10</span></span><br><span class="line">volumes=[<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">worths=[<span class="number">0</span>,<span class="number">10</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">50</span>]</span><br><span class="line">getMaxWorth(amount, total_capacity, volumes, worths)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">       [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,  <span class="number">10</span>,  <span class="number">10</span>,  <span class="number">10</span>,  <span class="number">10</span>,  <span class="number">10</span>,  <span class="number">20</span>],</span><br><span class="line">       [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,  <span class="number">40</span>,  <span class="number">40</span>,  <span class="number">40</span>,  <span class="number">40</span>,  <span class="number">80</span>,  <span class="number">80</span>,  <span class="number">80</span>],</span><br><span class="line">       [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,  <span class="number">40</span>,  <span class="number">40</span>,  <span class="number">40</span>,  <span class="number">40</span>,  <span class="number">80</span>,  <span class="number">80</span>,  <span class="number">80</span>],</span><br><span class="line">       [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,  <span class="number">50</span>,  <span class="number">50</span>,  <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">150</span>, <span class="number">150</span>]])</span><br></pre></td></tr></table></figure>
<p>上面的时间复杂度分析：此问题和01背包问题一样，有$O(N*V)$个状态需要求解，但是每一个状态求解的时间已经发生了变化，求解状态f[i][v]的时间为O(v/c[i])，总的时间复杂度超过了O(NV)，其中N是物品数量，V是背包容量。</p>
<h2 id="2-1-简单优化方案"><a href="#2-1-简单优化方案" class="headerlink" title="2.1 简单优化方案"></a>2.1 简单优化方案</h2><p>若两件物品i,j满足 volumes[i]&lt; volumes[j]  并且 worths[i]&gt;worths[j]，则说明i物品体积小并且价值高，可以替换物品j，也就是可以将物品j删除掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_can_be_delete_item_index</span><span class="params">(volumes, worths)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    delete items with small volume and small value</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    index_for_delete = set()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(volumes)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(volumes)):</span><br><span class="line">            <span class="keyword">if</span> volumes[i] &gt; volumes[j] <span class="keyword">and</span> worths[i] &lt; worths[j]:</span><br><span class="line">                 index_for_delete.add(i)</span><br><span class="line">    <span class="keyword">return</span> index_for_delete</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMaxWorth</span><span class="params">(amount, total_capacity, volumes, worths)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        amount: the quantity of things  type-int</span></span><br><span class="line"><span class="string">        total_capacity: the volume of backpack  type-int</span></span><br><span class="line"><span class="string">        volumes: the volume of each thing  type-list</span></span><br><span class="line"><span class="string">        worths: the worth of each thing    type-list</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    new_volumes = []</span><br><span class="line">    new_worths = []</span><br><span class="line">    index_delete = get_can_be_delete_item_index(volumes, worths)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(volumes)):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> index_delete:</span><br><span class="line">            new_volumes.append(volumes[i])</span><br><span class="line">            new_worths.append(worths[i])</span><br><span class="line"><span class="comment">#     print(new_volumes, new_worths)</span></span><br><span class="line"></span><br><span class="line">    amount = len(new_volumes)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># create a amount*total_capacity array and initialization</span></span><br><span class="line">    f = np.zeros((amount,total_capacity+<span class="number">1</span>), dtype=int)</span><br><span class="line">    </span><br><span class="line">    volumes = new_volumes</span><br><span class="line">    worths = new_worths</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># repeat</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,amount):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,total_capacity+<span class="number">1</span>):</span><br><span class="line">            temp = []</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> k*volumes[i] &lt;= j :</span><br><span class="line">                temp.append(f[i<span class="number">-1</span>][j-k*volumes[i]]+k*worths[i])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            f[i][j] = max(temp)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amount = <span class="number">4</span></span><br><span class="line">total_capacity=<span class="number">10</span></span><br><span class="line">volumes=[<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">worths=[<span class="number">0</span>,<span class="number">10</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">50</span>]</span><br><span class="line">getMaxWorth(amount, total_capacity, volumes, worths)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0],</span><br><span class="line">       [  0,   0,   0,  50,  50,  50, 100, 100, 100, 150, 150]])</span><br></pre></td></tr></table></figure>
<p>此问题还可以试着输出一下被选择的物品和次数之间的关系，以及如何选择物品可以恰好装满</p>
<h1 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3 多重背包问题"></a>3 多重背包问题</h1><p>在问题的基础上，增加每件物品的件数，比如，第i种物品最多n[i]件可用。<br>转移状态方程：共有N种物品，假设f[i-1][v]是将前i-1种物品放入容量v中时的最大价值，那么针对第i种物品，它最多可以放入n[i]次，此时的转义方程如下：</p>
<p>$$<br>f[i][v] = max(f[i-1][v-k<em>c[i]]+k</em>w[i] | 0&lt;=k&lt;=n[i])<br>$$<br>因此，在上面代码的基础上做了一些改变，如下。其中需要注意在逆推得到每件物品的时候，从最后一种物品开始，体积是从V开始并且不是遍历V，而是根据结果动态改变计算出下一次的V<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMaxWorth</span><span class="params">(amount, total_capacity, volumes, worths, counts)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        amount: the quantity of things  type-int</span></span><br><span class="line"><span class="string">        total_capacity: the volume of backpack  type-int</span></span><br><span class="line"><span class="string">        volumes: the volume of each thing  type-list</span></span><br><span class="line"><span class="string">        worths: the worth of each thing    type-list</span></span><br><span class="line"><span class="string">        counts: the number of each thing type-list</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># create a amount*total_capacity array and initialization</span></span><br><span class="line">    f = np.zeros((amount + <span class="number">1</span>, total_capacity + <span class="number">1</span>), dtype=int)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># repeat</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, total_capacity + <span class="number">1</span>):</span><br><span class="line">            temp = []</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> k * volumes[i] &lt;= j <span class="keyword">and</span> k &lt;= counts[i]:</span><br><span class="line">                temp.append(f[i - <span class="number">1</span>][j - k * volumes[i]] + k * worths[i])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            f[i][j] = max(temp)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_the_goods</span><span class="params">(f, amount, total_capacity, counts, volumes,worths)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        f: the f[i][v]</span></span><br><span class="line"><span class="string">        amount: the number of things</span></span><br><span class="line"><span class="string">        return: the goods and its choosed times</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(amount, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, counts[i] + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> total_capacity-k*volumes[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># note: the point is to use the state transfer formula to compute the k value</span></span><br><span class="line">                <span class="keyword">while</span> f[i][total_capacity] == f[i - <span class="number">1</span>][total_capacity-k*volumes[i]] + k * worths[i]:</span><br><span class="line">                    total_capacity -= k * volumes[i]</span><br><span class="line">                    print(<span class="string">"第%d件物品取%d件"</span> % (i, k))</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amount = <span class="number">3</span></span><br><span class="line">total_capacity = <span class="number">8</span></span><br><span class="line">volumes = [<span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">worths = [<span class="number">0</span>, <span class="number">6</span>,<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line">counts = [<span class="number">0</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">f = getMaxWorth(amount, total_capacity, volumes, worths, counts)</span><br><span class="line">print(f)</span><br><span class="line">get_the_goods(f, amount, total_capacity, counts, volumes,worths)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输出</span><br><span class="line">[[ 0  0  0  0  0  0  0  0  0]</span><br><span class="line"> [ 0  6 12 18 24 30 36 42 48]</span><br><span class="line"> [ 0  6 12 18 24 30 36 42 48]</span><br><span class="line"> [ 0  6 20 26 40 46 52 58 64]]</span><br><span class="line">第3件物品取2件</span><br><span class="line">第1件物品取4件</span><br></pre></td></tr></table></figure>
<p>根据以上代码可以发现，该算法的时间复杂度是$O(V \times \sum{counts[i]})$（时间复杂度计算：比如第一种物品的时候，会执行$V \times counts[1]$次，第二种物品，程序会执行$V \times counts[2]$次，因此可以得到总的时间复杂度）可以发现时间复杂度与物品的次数有关。  </p>
<p>该方法可以转化成01背包问题进行思考，就是将第i种物品，如果出现次数为n[i]，此时可以得到一个包含有$\sum{n[i]}$中物品的01背包问题，此时的时间复杂度仍然是$O(V \times \sum{counts[i]})$</p>
<p>方法：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值是原来的物品的费用和价值乘以这个系数，使这些系数分别为$1,2,4,…2^{(k-1)}$，其中k应该满足 $n[i]-2^k+1&gt;0$的最大整数，比如，n[i]=13，那么k最大为3，从而得到1,2,4；之后使用n[i]-(1+2+4)得到6，因此可以将这个物品的系数分为1,2,4,6；这样的系数可以表示0~n[i]中的每一个整数，同时n[i]件物品对应的就变成了$log(n[i])$件物品，事件复杂度为$O(V \times \sum{log({n[i]}))}$。</p>
<p>其中，将背包中对应数量的物品拆分成指定系数的物品代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiple_pack</span><span class="params">(volumes, worths, counts)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    make the count of goods to different v and w goods</span></span><br><span class="line"><span class="string">    :param volumes: list</span></span><br><span class="line"><span class="string">    :param worths: list</span></span><br><span class="line"><span class="string">    :param counts: list</span></span><br><span class="line"><span class="string">    :return: tuple(list,list,list)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    v = [<span class="number">0</span>]</span><br><span class="line">    w = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(counts)):</span><br><span class="line">        <span class="comment"># get the max value k according to the counts[i]</span></span><br><span class="line">        k = int(math.sqrt(counts[i]))</span><br><span class="line">        <span class="comment"># generate the coeffcient according to k</span></span><br><span class="line">        k_list = [math.pow(<span class="number">2</span>,item) <span class="keyword">for</span> item <span class="keyword">in</span> range(k)]</span><br><span class="line">        k_list.append(counts[i]-sum(k_list))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> k_list:</span><br><span class="line">            v.append(int(item * volumes[i]))</span><br><span class="line">            w.append(int(item * worths[i]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (v, w)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">volumes = [0, 1, 2, 2]</span><br><span class="line">worths = [0, 6, 10, 20]</span><br><span class="line">counts = [0, 10, 5, 2]</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">[0, 1, 2, 4, 3, 2, 4, 4, 2, 2]  </span><br><span class="line">[0, 6, 12, 24, 18, 10, 20, 20, 20, 20]</span><br></pre></td></tr></table></figure>
<p>之后使用01背包问题进行求解，代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_f_of_01_backpack</span><span class="params">(n, total_capacity, volumes, worths)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param n: the number of goods</span></span><br><span class="line"><span class="string">    :param volumes: list</span></span><br><span class="line"><span class="string">    :param worths: list</span></span><br><span class="line"><span class="string">    :return: f</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># initialization</span></span><br><span class="line">    f = np.zeros((n+<span class="number">1</span>, total_capacity+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#repeat</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, total_capacity+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j-volumes[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                f[i][j] = max(f[i<span class="number">-1</span>][j], f[i<span class="number">-1</span>][j-volumes[i]]+worths[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j]</span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">n = 9</span><br><span class="line">total_capacity = 8</span><br><span class="line">volumes = [0, 1, 2, 4, 3, 2, 4, 4, 2, 2]  </span><br><span class="line">worths = [0, 6, 12, 24, 18, 10, 20, 20, 20, 20]</span><br><span class="line">输出</span><br><span class="line">[[ 0.  0.  0.  0.  0.  0.  0.  0.  0.]</span><br><span class="line"> [ 0.  6.  6.  6.  6.  6.  6.  6.  6.]</span><br><span class="line"> [ 0.  6. 12. 18. 18. 18. 18. 18. 18.]</span><br><span class="line"> [ 0.  6. 12. 18. 24. 30. 36. 42. 42.]</span><br><span class="line"> [ 0.  6. 12. 18. 24. 30. 36. 42. 48.]</span><br><span class="line"> [ 0.  6. 12. 18. 24. 30. 36. 42. 48.]</span><br><span class="line"> [ 0.  6. 12. 18. 24. 30. 36. 42. 48.]</span><br><span class="line"> [ 0.  6. 12. 18. 24. 30. 36. 42. 48.]</span><br><span class="line"> [ 0.  6. 20. 26. 32. 38. 44. 50. 56.]</span><br><span class="line"> [ 0.  6. 20. 26. 40. 46. 52. 58. 64.]]</span><br></pre></td></tr></table></figure>
<p>通过逆向推导，可以得到被选择的物品。从最后一个物品开始遍历，直到到达第一个物品，需要注意的是提及V是根据结果进行动态调整的，最开始应该是体积V。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path_of_01_backpack</span><span class="params">(n,total_capacity, volumes, f)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> f[i][total_capacity] != f[i<span class="number">-1</span>][total_capacity]:</span><br><span class="line">            total_capacity -= volumes[i]</span><br><span class="line">            print(i)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>与上面的第一种方法进行对比可以看出结果是一样的，选择的东西也是一样的，只不过一个是拆开的物品。</p>
<p>本小结主要是关于将算法的复杂度进行改进，需要特别注意的是“拆分物品”的思想和方法。</p>
<h1 id="4-混合三种背包问题"><a href="#4-混合三种背包问题" class="headerlink" title="4 混合三种背包问题"></a>4 混合三种背包问题</h1><p>将前面三种背包的问题混合起来，也就是有的物品可以取一次(01背包)，有的物品可以无限次取(完全背包)，有的物品可以取有限次(多重背包问题)。应该怎么求解。我的思路就是有一个存储背包次数的数组，如果可取有限次，就对应的是物品的次数，如果是无限次，就先根据物品的体积和总体积得到每件物品的最大可取次数并填入数组中。</p>
<h1 id="5-二维费用的背包问题"><a href="#5-二维费用的背包问题" class="headerlink" title="5 二维费用的背包问题"></a>5 二维费用的背包问题</h1><p>对于每件物品，具有两种不同的费用：选择这件物品的时候必须同时付出两种代价，对于每种代价都有一个可以付出的最大值（比如背包容量V和<em>最多可取物品数量M</em>），问怎样选择物品可以达到最大价值。设第i件物品的两种代价分别为a[i]和b[i]，两种代价的最大值为V，M。</p>
<p>思路：<strong>费用增加一维，只需状态增加一维即可</strong>.设f[i][v][m]表示前i件物品付出v和m代价时的最大价值，那么状态转移方程如下：</p>
<p>$$<br>f[i][v][m] = max{f[i-1][v][m], f[i-1][v-a[i]][m-b[i]]+w[i]}<br>$$<br>当然，和前面的方法一样，也能使用二维数组来解决：当每件物品只可以取一次的时候，变量v，m逆序循环，当物品可以取无限次的时候，可以采用顺序的循环。当物品有如多重背包问题的时候，可以拆分物品，然后使用01背包问题求解。</p>
<h2 id="5-1-使用三维数组解决问题"><a href="#5-1-使用三维数组解决问题" class="headerlink" title="5.1 使用三维数组解决问题"></a>5.1 使用三维数组解决问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2-dimensional cost knapsack problem</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0-1 knapsack problem: two-dimensional array and one-dimensional array are used to resolve this problem</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack_2_array</span><span class="params">(N, V, M, A, B,  W)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param N: the number of goods</span></span><br><span class="line"><span class="string">    :param V: the total volume1 of goods</span></span><br><span class="line"><span class="string">    :param M: the total volume2 of goods</span></span><br><span class="line"><span class="string">    :param A: the volume1 of each goods  type-list</span></span><br><span class="line"><span class="string">    :param B: the volume2 of each goods  type-list</span></span><br><span class="line"><span class="string">    :param W: the weight of each goods type-list</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># initialization</span></span><br><span class="line">    f = np.zeros((V+<span class="number">1</span>, M+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialization for just full of M</span></span><br><span class="line">    <span class="comment"># f = np.zeros((V+1, M+1))</span></span><br><span class="line">    <span class="comment"># for i in range(V+1):</span></span><br><span class="line">    <span class="comment">#     for j in range(M+1):</span></span><br><span class="line">    <span class="comment">#         if j == 0:</span></span><br><span class="line">    <span class="comment">#             f[i][j] = 0</span></span><br><span class="line">    <span class="comment">#         else:</span></span><br><span class="line">    <span class="comment">#             f[i][j] = float('-inf')</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># repeat</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V, <span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(M, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> j-A[i] &gt;= <span class="number">0</span> <span class="keyword">and</span> k-B[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                    f[j][k] = max(f[j][k], f[j-A[i]][k-B[i]]+W[i])</span><br><span class="line">        <span class="comment"># print(f)</span></span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_choosed_goods</span><span class="params">(N, V, M, A, B, W, f)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> f[V][M] == f[V-A[i]][M-B[i]]+W[i] <span class="keyword">and</span> f[V][M] != float(<span class="string">'-inf'</span>) <span class="keyword">and</span> f[V-A[i]][M-B[i]] != float(<span class="string">'-inf'</span>):</span><br><span class="line">            V -= A[i]</span><br><span class="line">            M -= B[i]</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    N = <span class="number">5</span></span><br><span class="line">    V = <span class="number">10</span></span><br><span class="line">    M = <span class="number">10</span></span><br><span class="line">    A = [<span class="number">0</span>,<span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    B = [<span class="number">0</span>, <span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    W = [<span class="number">0</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">    f1 = knapsack_2_array(N, V, M, A, B, W)</span><br><span class="line">    print(f1)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">如果没有要求背包恰好装满，初始化的时候全部初始化为0即可，那么输出结果是：</span><br><span class="line">[[ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]</span><br><span class="line"> [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]</span><br><span class="line"> [ 0.  0.  5.  5.  5.  5.  5.  5.  5.  5.  5.]</span><br><span class="line"> [ 0.  0.  5.  5.  5.  5.  5.  5.  5.  5.  5.]</span><br><span class="line"> [ 0.  0.  5.  5. 10. 10. 10. 10. 10. 10. 10.]</span><br><span class="line"> [ 0.  0.  5.  5. 10. 10. 10. 10. 10. 10. 10.]</span><br><span class="line"> [ 0.  0.  5.  5. 10. 10. 15. 15. 15. 15. 15.]</span><br><span class="line"> [ 0.  0.  5.  5. 10. 10. 15. 15. 15. 15. 15.]</span><br><span class="line"> [ 0.  0.  5.  5. 10. 10. 15. 15. 15. 15. 15.]</span><br><span class="line"> [ 0.  0.  5.  5. 10. 10. 15. 15. 15. 20. 20.]</span><br><span class="line"> [ 0.  0.  5.  5. 10. 10. 15. 15. 19. 20. 20.]]</span><br><span class="line"></span><br><span class="line">5 4 2</span><br><span class="line"></span><br><span class="line">如果要求恰好装满M，也就是M=0的这一列为0，其余位-inf，那么初始化的结果为：</span><br><span class="line">[[  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]]</span><br><span class="line">输出结果</span><br><span class="line">[[  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf -inf -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf   5. -inf -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf   5.   5. -inf -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf   5.   5.  10. -inf -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf   5.   5.  10.  10. -inf -inf -inf -inf -inf]</span><br><span class="line"> [  0. -inf   5.   5.  10.  10.  15. -inf   8. -inf -inf]</span><br><span class="line"> [  0. -inf   5.   5.  10.  10.  15.  15.   8. -inf -inf]</span><br><span class="line"> [  0. -inf   5.   5.  10.  10.  15.  15.   8. -inf  13.]</span><br><span class="line"> [  0. -inf   5.   5.  10.  10.  15.  15.   8.  20.  13.]</span><br><span class="line"> [  0. -inf   5.   5.  10.  10.  15.  15.  19.  20.  13.]]</span><br><span class="line"> 被选择的物品</span><br><span class="line"> 4 1</span><br></pre></td></tr></table></figure>
<p>注意在输出被选择的物品的时候，是需要逆序输出的，同时需要注意存在float(‘-inf’) = float(‘-inf’)+10,也就是inf与一个数的和与inf相等，因此需要在输出的时候注意值是否为inf</p>
<p>思考：如何保证恰好满足V和M？该如何进行初始化？？</p>
<h1 id="6-分组的背包问题"><a href="#6-分组的背包问题" class="headerlink" title="6 分组的背包问题"></a>6 分组的背包问题</h1><p>有N件物品和一个容量为V的背包，第i件物品的体积和价值分别为c[i]和w[i]。这些物品被划分为若干组，每组中的物品相互冲突，最多选择一件。求解将哪些物品装入背包的时候可以使这些物品的体积总和不超过背包容量，且可以取得最大的价值。</p>
<p>思路：因为物品划分成了组，所以就以组作为索引，而不是物品。则问题可以描述为，针对第k组，选择本组中的某一件还是一件都不选。f[k][v]表示前k组在体积为v的时候取得的最大价值，那么状态转移方程为：</p>
<p>$$<br>f[k][v] = max{f[k-1][v], f[k-1][v-c[i]]+w[i]| i是第k组中的物品}<br>$$</p>
<p>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for k in 1--&gt;K:</span><br><span class="line">    for v in V--&gt;0:</span><br><span class="line">        # 对于k组中的每一个物品</span><br><span class="line">        for i in k:</span><br><span class="line">            f[v] = max&#123;f[v], f[v-c[i]]+w[i]&#125;</span><br></pre></td></tr></table></figure></p>
<p>分组背包问题可以使用完全背包问题中的提到的一个简单的优化方法，也就是在每个组中，根据2中的优化方式进行初步的筛选，删除体积大，价值小的物品</p>
<h1 id="7-有依赖的背包问题"><a href="#7-有依赖的背包问题" class="headerlink" title="7 有依赖的背包问题"></a>7 有依赖的背包问题</h1><p>问题描述：<br>背包问题的物品之间存在某种“依赖”的关系，比如物品i依赖于j，那么表示若选择i物品，那么j物品也一定要被选择（可以理解为j为主件，i为附件，附件可以有多个）。</p>
<p>思路：<br>首先想到的是，可以将主件和依赖于主件的附件组成一个集合，作为一个物品。但是此时可用的策略比较多，包括不选主件，仅选择主件，选择主件和1个附件，选择主件和2个附件，….，如果有n个附件，那么策略就有2^n+1种，为指数级。</p>
<p>一种优化：<br>可以对附件集合中的物品做一下优化，删除体积大并且价值小的物品。【S如果附件物品数量较少的时候并且每一个附件只能取一次，那么可能这种优化存在问题，就是也需要选择体积大并且价值小的物品。】</p>
<p>进一步优化：<br>对附件集合做0-1背包问题，可以得到一个体积从0到V-c[i]是的最大价值数组（i表示第i个主件，V是总体积），从而可以泛化为V-c[i]+1个物品（物品的体积为0到V-c[i],价值为01背包问题求解的最大价值），这样就将主件i的策略从指数级转化为V-c[i]+1种物品。</p>
<p>因此，对于N件物品，可以得到N个物品组，每一个组中有泛化的V-c[i]+1种物品（他们是互斥的，也就是不能同时取），此时就可以使用6中的分组背包问题求解。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>背包问题到这里就结束了吧，目前还有两讲我大致浏览了一下，准备在做碰到相关题目的时候再来看一下，便于理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/03/Algorithms/KnapsackProblems/" data-id="cjtinfpsn005qxw77v4jps5tn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态规划/">动态规划</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MachineLearningAndDataMining/支持向量机" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/23/MachineLearningAndDataMining/支持向量机/" class="article-date">
  <time datetime="2018-08-23T06:47:29.000Z" itemprop="datePublished">2018-08-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据挖掘/">数据挖掘</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/23/MachineLearningAndDataMining/支持向量机/">支持向量机</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文主要使用python机器学习包scikit-learn，使用UCI上的机器学习数据Iris进行分类。</p>
<h1 id="1-数据集"><a href="#1-数据集" class="headerlink" title="1 数据集"></a>1 数据集</h1><p>数据集是来自UCI机器学习数据仓库中的Iris数据，该数据包含4个特征，分别是sepal length,sepal width, petal length,petal width,总共有3类，分别是Iris Setosa, Iris Versicolour, Iris Virginica，每一类数据有50条样本，共计150条样本数据。部分数据如下所示：</p>
<p>5.1,3.5,1.4,0.2,Iris-setosa<br>4.9,3.0,1.4,0.2,Iris-setosa<br>4.7,3.2,1.3,0.2,Iris-setosa<br>4.6,3.1,1.5,0.2,Iris-setosa<br>5.0,3.6,1.4,0.2,Iris-setosa  </p>
<h1 id="2-开始编码"><a href="#2-开始编码" class="headerlink" title="2 开始编码"></a>2 开始编码</h1><h2 id="2-1-导入数据"><a href="#2-1-导入数据" class="headerlink" title="2.1 导入数据"></a>2.1 导入数据</h2><p>使用pandas进行数据的读取，首先将数据文件后缀名修改为csv，其中第一行会被默认的作为列名，有两种解决方法，一种是在数据中第一行添加对应的列名,另一种可以在read_csv中使用header=-1来从第一行读取数据。本文决定在数据集中添加列名。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">FILEPATH = <span class="string">r"C:\others\doc\data mining\Iris\Iris.csv"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datasets = pd.read_csv(open(FILEPATH),sep=<span class="string">","</span>);</span><br></pre></td></tr></table></figure>
<p>对数据进行预处理，将class列中的字符串对应的转换成数字。<br>将数据转化成二维列表，便于处理，转化之后的数据就直接是numpy的ndarray格式的数组，可以进行切分等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">type_change</span><span class="params">(s)</span>:</span></span><br><span class="line">    it = &#123;<span class="string">"Iris-setosa"</span>:<span class="number">0</span>, <span class="string">"Iris-versicolor"</span>:<span class="number">1</span>,<span class="string">"Iris-virginica"</span>:<span class="number">2</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> it[s]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据集的class列进行处理，得到类型转换之后的数据集。通过查看官方文档，可以找到converters参数进行转换。</span></span><br><span class="line">datasets = pd.read_csv(open(FILEPATH),sep=<span class="string">","</span>,converters=&#123;<span class="number">4</span>:type_change&#125;)</span><br><span class="line">datasets = datasets.values</span><br><span class="line">print(type(datasets))</span><br></pre></td></tr></table></figure>
<pre><code>&lt;class &apos;numpy.ndarray&apos;&gt;
</code></pre><h2 id="2-2-将数据切分成训练器和测试集"><a href="#2-2-将数据切分成训练器和测试集" class="headerlink" title="2.2 将数据切分成训练器和测试集"></a>2.2 将数据切分成训练器和测试集</h2><p>使用scitkie-learn中的一个方法，可以随机生成测试集和训练集。<br>sklearn.model_selection.train_test_split(train_data, train_target, test_size, train_size, random_state)</p>
<ul>
<li>test_size 默认情况下为0.25,可以为浮点数或者int型，在一致train_size的时候，它就确定了</li>
<li>random_state 随机数种子，其实就是改组随机数的编号，在需要重复试验的时候，保证得到一组一样的随机数。比如每次都填1，其他参数设置一样的情况下得到的随机数组是一样的，但是如果填0或者不填，每次都会不一样。随机数的产生取决于中农资；随机数和种子之间的关系遵从以下两个原则：种子不同，产生不同的随机数；种子相同，即使实例不同也产生相同的随机数。</li>
</ul>
<p>返回值跟传入的数组有关，如果有x，y，返回的就是2<em>len(x,y) = 2</em>x = 4。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">x,y = np.split(datasets, (<span class="number">4</span>,), axis=<span class="number">1</span>)    <span class="comment"># 将数据集的特征和标签分割开来</span></span><br><span class="line"></span><br><span class="line">x = x[:, :<span class="number">2</span>]   <span class="comment"># 这里取前面两个属性特征值来训练，是为了后面画图可以比较直观</span></span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=<span class="number">1</span>, train_size=<span class="number">0.6</span>)</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.3 训练SVM分类器</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">svm</span>.<span class="title">SVC</span><span class="params">(C=<span class="number">1.0</span>, kernel=’rbf’, degree=<span class="number">3</span>, gamma=’auto’, coef0=<span class="number">0.0</span>, shrinking=True, probability=False, tol=<span class="number">0.001</span>, cache_size=<span class="number">200</span>, class_weight=None, verbose=False, max_iter=<span class="number">-1</span>, decision_function_shape=’ovr’, random_state=None)</span></span></span><br><span class="line"><span class="class">官方文档：</span></span><br><span class="line"><span class="class"><span class="title">c</span>-支持向量分类：该实现是基于<span class="title">libsvm</span>，拟合事件复杂度大于样本数量的平方，因此当样本数量大于10000的时候就不适用了。同时它的多类支持是通过一对一的方案解决的。</span></span><br><span class="line"><span class="class">[全面的支持向量机文档]<span class="params">(http://scikit-learn.org/stable/modules/svm.html#svm-classification)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">- <span class="title">C</span> 惩罚参数</span></span><br><span class="line"><span class="class">- <span class="title">kernel</span> 内核函数，可以是<span class="title">linear</span>  <span class="title">poly</span>  <span class="title">rbf</span>  <span class="title">sigmoid</span>  <span class="title">precomputed</span> 分别是线性核函数、多项式核函数（最常用的径向机核函数就是高斯核函数）、径向机核函数、神经元的非线性作用函数核函数、用户自定义核函数。</span></span><br><span class="line"><span class="class">- <span class="title">degree</span> 当使用多项式核函数的时候，<span class="title">degree</span>定义了该核函数的多项式次数。</span></span><br><span class="line"><span class="class">- <span class="title">gamma</span> <span class="title">rbf</span>  <span class="title">poly</span>  <span class="title">sigmoid</span>的核系数。【具体含义不清楚】</span></span><br><span class="line"><span class="class">- <span class="title">decision_function_shape</span>   <span class="title">ovr</span>就是<span class="title">one</span> <span class="title">vs</span> <span class="title">rest</span>  一个类别与其他类别进行划分     <span class="title">ovo</span>  <span class="title">one</span> <span class="title">vs</span> <span class="title">one</span>类别两两之间进行划分，即使用二分类的方法模拟多分类的结果。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">```<span class="title">python</span></span></span><br><span class="line">classfication = SVC(C=0.8, kernel='rbf', gamma=20, decision_function_shape='ovr')</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据给定的训练数据训练拟合模型,这里的y_train需要转换成一个一维的数组</span></span><br><span class="line">classfication.fit(x_train, y_train.ravel())</span><br></pre></td></tr></table></figure>
<pre><code>SVC(C=0.8, cache_size=200, class_weight=None, coef0=0.0,
  decision_function_shape=&apos;ovr&apos;, degree=3, gamma=20, kernel=&apos;rbf&apos;,
  max_iter=-1, probability=False, random_state=None, shrinking=True,
  tol=0.001, verbose=False)
</code></pre><h3 id="2-3-1-关于分类之后的一些参数"><a href="#2-3-1-关于分类之后的一些参数" class="headerlink" title="2.3.1 关于分类之后的一些参数"></a>2.3.1 关于分类之后的一些参数</h3><ul>
<li>支持向量</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持向量</span></span><br><span class="line">classfication.support_vectors_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持向量的索引</span></span><br><span class="line">classfication.support_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持向量的个数</span></span><br><span class="line">classfication.n_support_</span><br></pre></td></tr></table></figure>
<pre><code>array([19, 27, 27])
</code></pre><h2 id="2-4-计算分类器的准确率"><a href="#2-4-计算分类器的准确率" class="headerlink" title="2.4 计算分类器的准确率"></a>2.4 计算分类器的准确率</h2><p>score(x,yweights=None) 返回给定数据x和标签y的平均准确率</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_accuray = classfication.score(x_train,y_train)</span><br><span class="line">test_accuracy = classfication.score(x_test, y_test)</span><br><span class="line">print(<span class="string">"训练集准确率为:%.5f, 测试集准确率为：%.5f"</span> % (train_accuray, test_accuracy))</span><br></pre></td></tr></table></figure>
<pre><code>训练集准确率为:0.87778, 测试集准确率为：0.81667
</code></pre><p>predict(x),呈现分类的结果。只用给数据即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classfication.predict(x_test)</span><br></pre></td></tr></table></figure>
<pre><code>array([0., 1., 2., 0., 2., 2., 2., 0., 0., 2., 1., 0., 2., 2., 1., 0., 1.,
       1., 0., 0., 1., 1., 2., 0., 2., 1., 0., 0., 1., 1., 2., 2., 1., 2.,
       1., 0., 1., 0., 2., 1., 2., 0., 1., 2., 2., 2., 0., 0., 0., 1., 0.,
       0., 2., 2., 2., 2., 2., 1., 2., 1.])
</code></pre><p>decision_function(x) 可以查看样本到分离超平面的距离,通过与上面的predict结果对比发现，所属类别为距离最大的那一类，这是为什么？</p>
<p>decision_function()  为每个样本提供每个类别的分数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classfication.decision_function(x_test)[:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 2.08923718,  0.95436859, -0.04360578],
       [-0.31687426,  2.31494218,  1.00193208],
       [-0.47479005,  1.01791306,  2.456877  ],
       [ 2.25585785,  0.87236638, -0.12822423]])
</code></pre><h2 id="2-5-绘制图像"><a href="#2-5-绘制图像" class="headerlink" title="2.5 绘制图像"></a>2.5 绘制图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画训练数据的图形</span></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">x = x_train[:,:<span class="number">1</span>].ravel()</span><br><span class="line">y = x_train[:,<span class="number">1</span>:<span class="number">2</span>].ravel()</span><br><span class="line"></span><br><span class="line">labels = y_train</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    <span class="keyword">if</span> labels[i] == <span class="number">0</span>:</span><br><span class="line">        plt.scatter(x[i],y[i], color=<span class="string">'red'</span>)</span><br><span class="line">    <span class="keyword">if</span> labels[i] == <span class="number">1</span>:</span><br><span class="line">        plt.scatter(x[i],y[i],color=<span class="string">"g"</span>)</span><br><span class="line">    <span class="keyword">if</span> labels[i] == <span class="number">2</span>:</span><br><span class="line">        plt.scatter(x[i],y[i], color=<span class="string">"k"</span>)</span><br><span class="line">        </span><br><span class="line">plt.xlabel(<span class="string">'sepal length'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'sepal width'</span>)</span><br><span class="line">plt.title(<span class="string">'result'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/images/DataMiningTheory/SVM/scatter1.png"></p>
<p>使用color列表，就是根据标签决定不同的颜色，然后进行绘制，绘制结果和上图一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">x = x_train[:,:<span class="number">1</span>].ravel()</span><br><span class="line">y = x_train[:,<span class="number">1</span>:<span class="number">2</span>].ravel()</span><br><span class="line"></span><br><span class="line">labels = y_train</span><br><span class="line">color = [];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(labels)):</span><br><span class="line">    <span class="keyword">if</span> labels[i] == <span class="number">0</span>:</span><br><span class="line">        color.append(<span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">if</span> labels[i] == <span class="number">1</span>:</span><br><span class="line">        color.append(<span class="string">'g'</span>)</span><br><span class="line">    <span class="keyword">if</span> labels[i] == <span class="number">2</span>:</span><br><span class="line">        color.append(<span class="string">'k'</span>)</span><br><span class="line">plt.scatter(x,y,c=color)</span><br><span class="line">        </span><br><span class="line">plt.xlabel(<span class="string">'sepal length'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'sepal width'</span>)</span><br><span class="line">plt.title(<span class="string">'result'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/images/DataMiningTheory/SVM/scatter1.png"></p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>目前暂时只是简单的使用sklearn中的SVM分类器对UCI中的Iris数据进行分类。之后还需要了解SVM的其他具体参数的设置以及其他的一些，比如回归等。可以参考的内容：<br><a href="http://scikit-learn.org/stable/modules/svm.html" target="_blank" rel="noopener">svm</a><br><a href="http://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html" target="_blank" rel="noopener">svc</a><br><a href="http://scikit-learn.org/stable/auto_examples/svm/plot_iris.html#sphx-glr-auto-examples-svm-plot-iris-py" target="_blank" rel="noopener">plot svm</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/23/MachineLearningAndDataMining/支持向量机/" data-id="cjtinfpr90043xw77nt6uptzf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sklearn/">sklearn</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/支持向量机/">支持向量机</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python3/numpy1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/18/python3/numpy1/" class="article-date">
  <time datetime="2018-08-18T09:09:16.000Z" itemprop="datePublished">2018-08-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python3/">python3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/18/python3/numpy1/">numpy1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>numpy的一些使用。哔哩哔哩视频<a href="https://www.bilibili.com/video/av16378934/?p=1" target="_blank" rel="noopener">here</a></p>
<h2 id="axis理解"><a href="#axis理解" class="headerlink" title="axis理解"></a>axis理解</h2><p>轴用来为超过一维的数组定义的属性，二维数据拥有两个轴：第0轴沿着行的垂直往下，第1轴沿着列的方向水平延伸。<br><img src="/images/Python/numpy/axis.jpg" width="400px"></p>
<h1 id="1-random函数的使用"><a href="#1-random函数的使用" class="headerlink" title="1 random函数的使用"></a>1 random函数的使用</h1><p>主要有一些一些函数的使用</p>
<ul>
<li>normal()</li>
<li>random()</li>
</ul>
<h2 id="1-1-normal"><a href="#1-1-normal" class="headerlink" title="1.1 normal"></a>1.1 normal</h2><p>numpy.random.normal(loc=0.0, scale=1.0, size=None)<br>从正态分布中抽取随机样本</p>
<ul>
<li>loc 分布的平均值</li>
<li>scale 标准偏差</li>
<li>size 整数或者元组，比如(m,n,k),那么得到的就是m行，n列，k高的三维数组列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.random.normal(<span class="number">0</span>, <span class="number">0.5</span>, (<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.06158366,  0.94496841, -0.42095387, -0.16682898],
       [-0.3145212 , -0.41039232,  0.12504023, -0.17090629],
       [ 0.32857722, -0.25585145, -0.1607699 ,  0.228075  ]])
</code></pre><h2 id="1-2-random"><a href="#1-2-random" class="headerlink" title="1.2 random"></a>1.2 random</h2><p>numpy.random.random(size=None) ，返回0-1间的数（不包含1），size的解释和上文一样，如果size=None,那么默认就是随机产生一个0-1间的数字<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.random((<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure></p>
<p> array([[0.08519073, 0.40447468, 0.92314145, 0.11433058],<br>           [0.08232515, 0.89703947, 0.86035142, 0.7718275 ],<br>           [0.69032194, 0.88780312, 0.92649113, 0.72175598]])</p>
<h2 id="1-3-randint"><a href="#1-3-randint" class="headerlink" title="1.3 randint"></a>1.3 randint</h2><p>numpy.random.randint(low, high=None, size=None, dtype=’l’)  [low, high)<br>size表示元素的个数，可以是int，tuple<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z1 = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">print(Z1, Z2)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([9, 4, 0, 8, 6, 6, 9, 8, 1, 8])</span><br></pre></td></tr></table></figure>
<h2 id="1-4-uniform"><a href="#1-4-uniform" class="headerlink" title="1.4 uniform"></a>1.4 uniform</h2><p>numpy.random.uniform介绍：</p>
<p> 函数原型：  numpy.random.uniform(low,high,size)</p>
<p>功能：从一个均匀分布[low,high)中随机采样，注意定义域是左闭右开，即包含low，不包含high.</p>
<p>参数介绍: </p>
<pre><code>low: 采样下界，float类型，默认值为0；
high: 采样上界，float类型，默认值为1；
size: 输出样本数目，为int或元组(tuple)类型，例如，size=(m,n,k), 则输出m*n*k个样本，缺省时输出1个值。
</code></pre><p>返回值：ndarray类型，其形状和参数size中描述一致。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.uniform(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="2-数组的转置"><a href="#2-数组的转置" class="headerlink" title="2 数组的转置"></a>2 数组的转置</h1><h2 id="2-1-一维数组的转置-reshape"><a href="#2-1-一维数组的转置-reshape" class="headerlink" title="2.1 一维数组的转置  reshape"></a>2.1 一维数组的转置  reshape</h2><p>reshape()  numpy.reshape(a, newshape, order=’C’)</p>
<ul>
<li>a 表示原始的要整型的数组</li>
<li>newshape，可以是一个整数或者一个元组。比如转换成一列，可以使用(-1,1),转换成一行可以使用(1,-1)   ,-1表示不确定多少行（列）</li>
<li>order暂时用不上，没有了解</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">a = a.reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">b = np.reshape(a, (<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">b</span><br><span class="line"><span class="comment"># 使用a.T 无效</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[1],
       [2],
       [3],
       [4],
       [5],
       [6]])
</code></pre><h1 id="3-基本运算"><a href="#3-基本运算" class="headerlink" title="3 基本运算"></a>3 基本运算</h1><p>包括</p>
<ul>
<li>sum</li>
<li>max min mean average median  cumsum diff </li>
<li>mean</li>
<li>矩阵乘法</li>
<li>加减法</li>
<li>nonzero sort transpose(转置  A.T) clip  这些方法还没有学习，需要的时候再说。</li>
</ul>
<h2 id="3-1-总体上"><a href="#3-1-总体上" class="headerlink" title="3.1 总体上"></a>3.1 总体上</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="comment"># 计算所有项的和</span></span><br><span class="line">a.sum()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算最大值,最小值，均值</span></span><br><span class="line">a.max()</span><br><span class="line">a.min()</span><br><span class="line">a.mean()</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">2</span>,<span class="number">14</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">np.mean(a)  <span class="comment"># 7.5    a.mean()</span></span><br><span class="line">np.average(a)  <span class="comment"># 同上</span></span><br><span class="line">np.median(a)  <span class="comment"># 中位数</span></span><br><span class="line">print(a)</span><br><span class="line">np.cumsum(a)  <span class="comment"># 累加，第一个值是原数组的第一个值，第二值是原数组前两个数值的和，第三个值是原数组前三个值的和，依次类推</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>],[<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>]])</span><br><span class="line">np.diff(a)  <span class="comment"># 还有其他参数，用到的时候再说。</span></span><br><span class="line"><span class="comment">#array([[ 2,  1],</span></span><br><span class="line">    <span class="comment">#    [ 3,  3],</span></span><br><span class="line">    <span class="comment">#    [-2,  4]])</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2-行或者列上"><a href="#3-2-行或者列上" class="headerlink" title="3.2 行或者列上"></a>3.2 行或者列上</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算每一行的和</span></span><br><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>]).reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># a  [[10 20 30]</span></span><br><span class="line"><span class="comment">#  [40 50 60]]</span></span><br><span class="line">a.max(axis=<span class="number">1</span>)    <span class="comment">#  寻找每一行的最大值  array([20, 40])</span></span><br><span class="line">a.sum(axis = <span class="number">1</span>) <span class="comment"># 对每一行进行求和  array([ 60, 150])</span></span><br><span class="line">a.sum(axis=<span class="number">0</span>)  <span class="comment"># array([50, 70, 90])</span></span><br></pre></td></tr></table></figure>
<h2 id="3-3-乘法"><a href="#3-3-乘法" class="headerlink" title="3.3 乘法"></a>3.3 乘法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = np.array([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]])</span><br><span class="line"><span class="comment"># 矩阵乘法  dot</span></span><br><span class="line">a.dot(b)    </span><br><span class="line">np.dot(a,b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对应位置相乘，不清楚为什么矩阵的行列不相等的时候也可以进行乘法运算</span></span><br><span class="line">a*b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵乘法</span></span><br><span class="line">Z = np.dot(np.ones((<span class="number">5</span>,<span class="number">3</span>)), np.ones((<span class="number">3</span>,<span class="number">2</span>)))</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alternative solution, in Python 3.5 and above</span></span><br><span class="line">Z = np.ones((<span class="number">5</span>,<span class="number">3</span>)) @ np.ones((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">print(Z)</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [2, 4, 6],
       [3, 6, 9]])
</code></pre><h2 id="3-4-加减法-指数次幂"><a href="#3-4-加减法-指数次幂" class="headerlink" title="3.4 加减法 指数次幂"></a>3.4 加减法 指数次幂</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]).reshape((<span class="number">2</span>,<span class="number">2</span>,))</span><br><span class="line">b = np.arange(<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">a*b   <span class="comment">#array([[  0,  20], [ 60, 120]])    对应位置对应元素相乘</span></span><br><span class="line">np.dot(a,b)   <span class="comment"># array([[ 40,  70], [ 80, 150]])   矩阵的乘法</span></span><br><span class="line">a.dot(b)   <span class="comment"># 和上面的一样</span></span><br></pre></td></tr></table></figure>
<p><strong>不同shape的数组做减法时</strong>，但是列数需要是一样的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">arr2 = np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">arr1-arr2</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[0, 2, 2],</span><br><span class="line">       [1, 3, 3]])</span><br></pre></td></tr></table></figure>
<h2 id="3-5-sin-cos-tan"><a href="#3-5-sin-cos-tan" class="headerlink" title="3.5 sin cos tan"></a>3.5 sin cos tan</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = np.sin(b)</span><br><span class="line">c  <span class="comment">#array([0.        , 0.84147098, 0.90929743, 0.14112001])</span></span><br></pre></td></tr></table></figure>
<h2 id="3-6-小于-大于"><a href="#3-6-小于-大于" class="headerlink" title="3.6 小于  大于"></a>3.6 小于  大于</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line">b = np.arange(<span class="number">4</span>)</span><br><span class="line">a&lt;<span class="number">25</span>   <span class="comment">#array([ True,  True,  True, False])</span></span><br><span class="line">a[a&lt;<span class="number">25</span>]  <span class="comment"># array([10, 20])</span></span><br></pre></td></tr></table></figure>
<h2 id="3-7-寻找指定值所在的索引-argmin-argmax"><a href="#3-7-寻找指定值所在的索引-argmin-argmax" class="headerlink" title="3.7 寻找指定值所在的索引  argmin  argmax"></a>3.7 寻找指定值所在的索引  argmin  argmax</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">2</span>,<span class="number">14</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">a.argmin()   <span class="comment"># 0</span></span><br><span class="line">a.argmax()  <span class="comment"># 11</span></span><br></pre></td></tr></table></figure>
<h2 id="3-8-std-标准差"><a href="#3-8-std-标准差" class="headerlink" title="3.8 std 标准差"></a>3.8 std 标准差</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Z = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">np.std(Z)</span><br><span class="line"><span class="comment"># 0.816496580927726</span></span><br><span class="line">Z = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">np.std(Z)   <span class="comment"># 求二维数组中所有元素的标准差</span></span><br></pre></td></tr></table></figure>
<h2 id="3-9-amax-amin"><a href="#3-9-amax-amin" class="headerlink" title="3.9 amax  amin"></a>3.9 amax  amin</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score = np.array([[<span class="number">80</span>, <span class="number">88</span>], [<span class="number">82</span>, <span class="number">81</span>], [<span class="number">84</span>, <span class="number">75</span>], [<span class="number">86</span>, <span class="number">83</span>], [<span class="number">75</span>, <span class="number">81</span>]])</span><br><span class="line">score</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[80, 88],</span><br><span class="line">       [82, 81],</span><br><span class="line">       [84, 75],</span><br><span class="line">       [86, 83],</span><br><span class="line">       [75, 81]])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.amax(score, axis=<span class="number">0</span>)  <span class="comment"># 求每一列的最大值</span></span><br><span class="line">np.amax(score, axis=<span class="number">1</span>)  <span class="comment"># 求每一行的最大值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([86, 88])</span><br><span class="line">array([88, 82, 84, 86, 81])</span><br></pre></td></tr></table></figure>
<h1 id="4-numpy的创建"><a href="#4-numpy的创建" class="headerlink" title="4 numpy的创建"></a>4 numpy的创建</h1><h2 id="4-1-使用列表（元组）创建"><a href="#4-1-使用列表（元组）创建" class="headerlink" title="4.1 使用列表（元组）创建"></a>4.1 使用列表（元组）创建</h2><p>注意数据类型  dtype，一维和二维的定义。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a =np.array([<span class="number">2</span>,<span class="number">33</span>,<span class="number">4</span>], dtype=np.int64)     <span class="comment">#np.float32    float64</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">type(a)  <span class="comment">#numpy.ndarray    </span></span><br><span class="line">print(a.dtype)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种</span></span><br><span class="line">f1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">f2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">list(zip(f1,f2))   <span class="comment">#[(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line">np.array(list(zip(f1,f2)))</span><br><span class="line">输出：</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure></p>
<h2 id="4-2-zero-ones"><a href="#4-2-zero-ones" class="headerlink" title="4.2 zero   ones"></a>4.2 zero   ones</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.zeros((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">np.ones((<span class="number">3</span>,<span class="number">4</span>))   <span class="comment"># 值全为1</span></span><br></pre></td></tr></table></figure>
<h2 id="4-3-arange-reshape"><a href="#4-3-arange-reshape" class="headerlink" title="4.3 arange   reshape"></a>4.3 arange   reshape</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(10,22,2)</span><br><span class="line">a.reshape((2,3))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([10,12,14,16,18,20])</span><br><span class="line">array([[10, 12, 14],</span><br><span class="line">       [16, 18, 20]])</span><br></pre></td></tr></table></figure>
<h2 id="4-4-nonzero"><a href="#4-4-nonzero" class="headerlink" title="4.4 nonzero"></a>4.4 nonzero</h2><p>Find indices of non-zero elements from<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nz = np.nonzero([<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>])</span><br><span class="line">nz</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># (array([0, 1, 4], dtype=int64),)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="4-5-eye"><a href="#4-5-eye" class="headerlink" title="4.5 eye"></a>4.5 eye</h2><p>Create a 3x3 identity matrix<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.eye(<span class="number">3</span>)</span><br><span class="line">print(Z)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 单位矩阵</span><br><span class="line">[[1. 0. 0.]</span><br><span class="line"> [0. 1. 0.]</span><br><span class="line"> [0. 0. 1.]]</span><br></pre></td></tr></table></figure>
<h2 id="4-4-linspace"><a href="#4-4-linspace" class="headerlink" title="4.4 linspace"></a>4.4 linspace</h2><p>numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</p>
<ul>
<li>start 序列起点</li>
<li>stop  序列终点</li>
<li>num   生成的样本数</li>
<li>endpoint  bool optional  True表示包含序列终点</li>
<li>restep   bool  optional  True表示显示每一步的大小<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">3</span>,num=<span class="number">5</span>)   <span class="comment">#array([1. , 1.5, 2. , 2.5, 3. ])</span></span><br><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">3</span>,num=<span class="number">5</span>, endpoint=<span class="literal">False</span>) <span class="comment">#array([1. , 1.4, 1.8, 2.2, 2.6])</span></span><br><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">3</span>,num=<span class="number">5</span>, retstep=<span class="literal">True</span>) <span class="comment"># (array([1. , 1.5, 2. , 2.5, 3. ]), 0.5)   是一个元组</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="5-排序"><a href="#5-排序" class="headerlink" title="5 排序"></a>5 排序</h1><ul>
<li>sort(a[, axis, kind, order])    Return a sorted copy of an array.</li>
<li>lexsort(keys[, axis])    Perform an indirect sort using a sequence of keys.</li>
<li>argsort(a[, axis, kind, order])    Returns the indices that would sort an array.</li>
<li>ndarray.sort([axis, kind, order])    Sort an array, in-place.</li>
<li>msort(a)    Return a copy of an array sorted along the first axis.</li>
<li>sort_complex(a)    Sort a complex array using the real part first, then the imaginary part.</li>
<li>partition(a, kth[, axis, kind, order])    Return a partitioned copy of an array.</li>
<li>argpartition(a, kth[, axis, kind, order])    Perform an indirect partition along the given axis using the algorithm specified by the kind keyword.</li>
</ul>
<h2 id="5-1-sort"><a href="#5-1-sort" class="headerlink" title="5.1 sort"></a>5.1 sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random(<span class="number">10</span>)</span><br><span class="line">Z.sort()</span><br><span class="line">print(Z)</span><br><span class="line"><span class="comment"># [0.04063356 0.13948625 0.29767669 0.36496056 0.47147676 0.58858695  0.60859316 0.6758131  0.88066579 0.89901003]</span></span><br></pre></td></tr></table></figure>
<h1 id="6-小知识点"><a href="#6-小知识点" class="headerlink" title="6 小知识点"></a>6 小知识点</h1><h2 id="6-1-切片"><a href="#6-1-切片" class="headerlink" title="6.1 切片"></a>6.1 切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">10</span>,<span class="number">40</span>).reshape((<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">Z</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[10, 11, 12, 13, 14, 15],</span><br><span class="line">       [16, 17, 18, 19, 20, 21],</span><br><span class="line">       [22, 23, 24, 25, 26, 27],</span><br><span class="line">       [28, 29, 30, 31, 32, 33],</span><br><span class="line">       [34, 35, 36, 37, 38, 39]])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z[<span class="number">1</span>:<span class="number">-1</span>, <span class="number">1</span>:<span class="number">-1</span>]    <span class="comment"># 第一个控制行，第二个控制列，表示从第一行到倒数第二行，第一列到倒数第二列的元素</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[17, 18, 19, 20],</span><br><span class="line">       [23, 24, 25, 26],</span><br><span class="line">       [29, 30, 31, 32]])</span><br></pre></td></tr></table></figure>
<h2 id="6-2-How-to-add-a-border-filled-with-0’s-around-an-existing-array-增加边界"><a href="#6-2-How-to-add-a-border-filled-with-0’s-around-an-existing-array-增加边界" class="headerlink" title="6.2 How to add a border (filled with 0’s) around an existing array?(增加边界)"></a>6.2 How to add a border (filled with 0’s) around an existing array?(增加边界)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">Z = np.pad(Z, pad_width=<span class="number">1</span>, mode=<span class="string">'constant'</span>, constant_values=<span class="number">0</span>)</span><br><span class="line">print(Z)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[0. 0. 0. 0. 0. 0. 0.]</span><br><span class="line"> [0. 1. 1. 1. 1. 1. 0.]</span><br><span class="line"> [0. 1. 1. 1. 1. 1. 0.]</span><br><span class="line"> [0. 1. 1. 1. 1. 1. 0.]</span><br><span class="line"> [0. 1. 1. 1. 1. 1. 0.]</span><br><span class="line"> [0. 1. 1. 1. 1. 1. 0.]</span><br><span class="line"> [0. 0. 0. 0. 0. 0. 0.]]</span><br></pre></td></tr></table></figure>
<h2 id="6-3-找出array中相同的元素"><a href="#6-3-找出array中相同的元素" class="headerlink" title="6.3 找出array中相同的元素"></a>6.3 找出array中相同的元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z1 = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">Z2 = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">print(Z1, Z2)</span><br><span class="line">print(np.intersect1d(Z1,Z2))</span><br><span class="line"><span class="comment"># [1 6 3 5 4 8 4 8 2 8] [9 9 0 1 3 0 8 5 8 9]</span></span><br><span class="line"><span class="comment"># [1 3 5 8]</span></span><br></pre></td></tr></table></figure>
<h2 id="6-4-out使用"><a href="#6-4-out使用" class="headerlink" title="6.4 out使用"></a>6.4 out使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = np.ones(<span class="number">3</span>)*<span class="number">1</span></span><br><span class="line">B = np.ones(<span class="number">3</span>)*<span class="number">2</span></span><br><span class="line">C = np.ones(<span class="number">3</span>)*<span class="number">3</span></span><br><span class="line">np.add(A,B,out=B)</span><br><span class="line">np.divide(A,<span class="number">2</span>,out=A)</span><br><span class="line">np.negative(A,out=A)</span><br><span class="line">np.multiply(A,B,out=A)</span><br></pre></td></tr></table></figure>
<h2 id="6-5-提取出随机数的整数部分"><a href="#6-5-提取出随机数的整数部分" class="headerlink" title="6.5 提取出随机数的整数部分"></a>6.5 提取出随机数的整数部分</h2><p>以下五种方法都可以得到需要的结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.uniform(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">print(Z)</span><br><span class="line"><span class="keyword">print</span> (Z - Z%<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> (np.floor(Z))</span><br><span class="line"><span class="keyword">print</span> (np.ceil(Z)<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">print</span> (Z.astype(int))</span><br><span class="line"><span class="keyword">print</span> (np.trunc(Z))</span><br></pre></td></tr></table></figure></p>
<h2 id="6-6-使用0替换最大值"><a href="#6-6-使用0替换最大值" class="headerlink" title="6.6 使用0替换最大值"></a>6.6 使用0替换最大值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random(<span class="number">10</span>)</span><br><span class="line">Z[Z.argmax()] = <span class="number">0</span></span><br><span class="line">print(Z)</span><br></pre></td></tr></table></figure>
<h2 id="6-7-访问数组中的元素"><a href="#6-7-访问数组中的元素" class="headerlink" title="6.7 访问数组中的元素"></a>6.7 访问数组中的元素</h2><p>下面两种方法都可以访问数组中的第一行第一列元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">score = np.array([[<span class="number">80</span>, <span class="number">88</span>], [<span class="number">82</span>, <span class="number">81</span>], [<span class="number">84</span>, <span class="number">75</span>], [<span class="number">86</span>, <span class="number">83</span>], [<span class="number">75</span>, <span class="number">81</span>]])</span><br><span class="line">score</span><br><span class="line">score[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">score[<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="6-8"><a href="#6-8" class="headerlink" title="6.8"></a>6.8</h2><h1 id="7-元素操作"><a href="#7-元素操作" class="headerlink" title="7 元素操作"></a>7 元素操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">11</span>)</span><br><span class="line">Z[(<span class="number">3</span> &lt; Z) &amp; (Z &lt;= <span class="number">8</span>)] *= <span class="number">-1</span></span><br><span class="line">print(Z)</span><br><span class="line"><span class="comment"># [ 0  1  2  3 -4 -5 -6 -7 -8  9 10]</span></span><br></pre></td></tr></table></figure>
<h1 id="8-时间操作"><a href="#8-时间操作" class="headerlink" title="8 时间操作"></a>8 时间操作</h1><h2 id="8-1-获取多天，今天，明天的日期"><a href="#8-1-获取多天，今天，明天的日期" class="headerlink" title="8.1 获取多天，今天，明天的日期"></a>8.1 获取多天，今天，明天的日期</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yesterday = np.datetime64(<span class="string">'today'</span>, <span class="string">'D'</span>) - np.timedelta64(<span class="number">1</span>, <span class="string">'D'</span>)</span><br><span class="line">today     = np.datetime64(<span class="string">'today'</span>, <span class="string">'D'</span>)</span><br><span class="line">tomorrow  = np.datetime64(<span class="string">'today'</span>, <span class="string">'D'</span>) + np.timedelta64(<span class="number">1</span>, <span class="string">'D'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="8-2-获取某个时间段内的所有日期"><a href="#8-2-获取某个时间段内的所有日期" class="headerlink" title="8.2 获取某个时间段内的所有日期"></a>8.2 获取某个时间段内的所有日期</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="string">'2016-07'</span>, <span class="string">'2016-08'</span>, dtype=<span class="string">'datetime64[D]'</span>)</span><br><span class="line">print(Z)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&apos;2016-07-01&apos; &apos;2016-07-02&apos; &apos;2016-07-03&apos; &apos;2016-07-04&apos; &apos;2016-07-05&apos;</span><br><span class="line"> &apos;2016-07-06&apos; &apos;2016-07-07&apos; &apos;2016-07-08&apos; &apos;2016-07-09&apos; &apos;2016-07-10&apos;</span><br><span class="line"> &apos;2016-07-11&apos; &apos;2016-07-12&apos; &apos;2016-07-13&apos; &apos;2016-07-14&apos; &apos;2016-07-15&apos;</span><br><span class="line"> &apos;2016-07-16&apos; &apos;2016-07-17&apos; &apos;2016-07-18&apos; &apos;2016-07-19&apos; &apos;2016-07-20&apos;</span><br><span class="line"> &apos;2016-07-21&apos; &apos;2016-07-22&apos; &apos;2016-07-23&apos; &apos;2016-07-24&apos; &apos;2016-07-25&apos;</span><br><span class="line"> &apos;2016-07-26&apos; &apos;2016-07-27&apos; &apos;2016-07-28&apos; &apos;2016-07-29&apos; &apos;2016-07-30&apos;</span><br><span class="line"> &apos;2016-07-31&apos;]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/18/python3/numpy1/" data-id="cjtinfpru004hxw77ldoma290" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/numpy/">numpy</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python3/pandas1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/18/python3/pandas1/" class="article-date">
  <time datetime="2018-08-18T09:08:48.000Z" itemprop="datePublished">2018-08-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python3/">python3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/18/python3/pandas1/">pandas1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>pandas的一些学习和使用</p>
<p>参考<a href="https://blog.csdn.net/qq_33399185/article/details/60872853" target="_blank" rel="noopener">here</a></p>
<h1 id="1-一些基本的操作"><a href="#1-一些基本的操作" class="headerlink" title="1 一些基本的操作"></a>1 一些基本的操作</h1><p>包括</p>
<ul>
<li>文件读取 统计信息，部分数据查看，绘制相关图形。</li>
</ul>
<h2 id="1-1-文件读取和写入"><a href="#1-1-文件读取和写入" class="headerlink" title="1.1 文件读取和写入"></a>1.1 文件读取和写入</h2><h3 id="1-1-1-文件读取"><a href="#1-1-1-文件读取" class="headerlink" title="1.1.1 文件读取"></a>1.1.1 文件读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">filename = <span class="string">"C:/Users/14259/Desktop/25周/watermelon.csv"</span></span><br><span class="line">dataset = pd.read_csv(open(filename), delimiter=<span class="string">","</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  显示一些统计信息</span></span><br><span class="line">dataset.describe()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示前几条记录显示后面几条记录使用tail</span></span><br><span class="line">dataset.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图形，参数是数据集的某列。</span></span><br><span class="line">dataset.hist(<span class="string">"密度"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-文件写入"><a href="#1-1-2-文件写入" class="headerlink" title="1.1.2 文件写入"></a>1.1.2 文件写入</h3><p>df.to_csv(filename)：导出数据到CSV文件</p>
<h2 id="1-2-关于列和行的操作"><a href="#1-2-关于列和行的操作" class="headerlink" title="1.2 关于列和行的操作"></a>1.2 关于列和行的操作</h2><p>包括</p>
<ul>
<li>loc  at  index  shape  columns  dtypes</li>
</ul>
<h3 id="1-2-1-一些基础的操作-loc-at-index-columns-shape等"><a href="#1-2-1-一些基础的操作-loc-at-index-columns-shape等" class="headerlink" title="1.2.1 一些基础的操作  loc  at  index  columns  shape等"></a>1.2.1 一些基础的操作  loc  at  index  columns  shape等</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">df = dataset</span><br><span class="line">df[<span class="string">'密度'</span>]    <span class="comment"># 获取columns为“密度”的列</span></span><br><span class="line">df[<span class="number">1</span>:<span class="number">3</span>]    <span class="comment"># get the first and second lines</span></span><br><span class="line">df.loc[<span class="number">1</span>:<span class="number">4</span>,<span class="string">'编号'</span>:<span class="string">'纹理'</span>]   <span class="comment">#行切片加列切片</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某一行</span></span><br><span class="line">df.iloc[index]</span><br><span class="line"></span><br><span class="line">df.at[<span class="number">4</span>,<span class="string">'色泽'</span>]    <span class="comment"># 获取指定位置的元素，第4行，色泽这一列</span></span><br><span class="line"></span><br><span class="line">df.dtypes</span><br><span class="line"></span><br><span class="line">df.index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看列索引</span></span><br><span class="line">df.columns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一行作为列表的一项进行返回</span></span><br><span class="line">df.values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一列作为列表的一项进行返回</span></span><br><span class="line">df = df.T</span><br><span class="line">df.values</span><br><span class="line"></span><br><span class="line">df.shape</span><br></pre></td></tr></table></figure>
<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gray是DataFrame类型</span></span><br><span class="line">std=gray.iloc[:,<span class="number">1</span>]<span class="comment">#第1列的Series</span></span><br><span class="line">std.head()</span><br><span class="line">type(std.head())  <span class="comment"># pandas.core.series.Series</span></span><br><span class="line"></span><br><span class="line">ce=gray.iloc[:,<span class="number">0</span>:]<span class="comment"># 从第0列开始所有列</span></span><br><span class="line">ce.head()   <span class="comment"># pandas.core.frame.DataFrame</span></span><br><span class="line">type(ce)</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-删除指定索引列-drop"><a href="#1-2-2-删除指定索引列-drop" class="headerlink" title="1.2.2 删除指定索引列 drop()"></a>1.2.2 删除指定索引列 drop()</h3><p>inplace = True，意思是直接在df对象上改变。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df = df.T</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>]   <span class="comment"># 从0开始计数的，这里是删除第1列和第2列</span></span><br><span class="line"><span class="comment"># x = ['column1','column2']   也可以直接指定列名</span></span><br><span class="line">df.drop(df.columns[x], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的索引行，注意axis=0</span></span><br><span class="line">df.drop(df.index[x], axis=<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-3-获取指定元素的值或者赋值"><a href="#1-2-3-获取指定元素的值或者赋值" class="headerlink" title="1.2.3 获取指定元素的值或者赋值"></a>1.2.3 获取指定元素的值或者赋值</h3><p>使用iloc赋值会有一个警告，目前不清楚是什么原因。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取列名为process_content的索引，之后使用.iloc()定位到该元素。</span></span><br><span class="line">d_index = list(df_part.columns).index(<span class="string">'process_content'</span>)</span><br><span class="line">df.iloc[index,d_index ] =<span class="string">"1234"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-4-对dataframe进行遍历"><a href="#1-2-4-对dataframe进行遍历" class="headerlink" title="1.2.4 对dataframe进行遍历"></a>1.2.4 对dataframe进行遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,row <span class="keyword">in</span> df,iterrows():</span><br><span class="line">    print(index, row);</span><br><span class="line"><span class="comment"># 每一个row是一个Series</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-5-提取dataframe中某些列成为一个新的dataframe"><a href="#1-2-5-提取dataframe中某些列成为一个新的dataframe" class="headerlink" title="1.2.5 提取dataframe中某些列成为一个新的dataframe"></a>1.2.5 提取dataframe中某些列成为一个新的dataframe</h3><p>df[[col1, col2]]：以DataFrame形式返回多列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_content = df_part[[<span class="string">"process_content"</span>, <span class="string">"keywords"</span>]]</span><br><span class="line">df_content</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-6-插入新列"><a href="#1-2-6-插入新列" class="headerlink" title="1.2.6 插入新列"></a>1.2.6 插入新列</h3><p>DataFrame.insert(loc, column, value, allow_duplicates=False)</p>
<ul>
<li>loc int, insertion index, 取值范围为0到len(columns)</li>
<li>column string, number等  列名</li>
<li>value  int  Series  array-like  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_content.insert(<span class="number">2</span>, <span class="string">"word_list"</span>, <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-7-DataFrame的行数和列数"><a href="#1-2-7-DataFrame的行数和列数" class="headerlink" title="1.2.7 DataFrame的行数和列数"></a>1.2.7 DataFrame的行数和列数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ce——DataFrame  ce的行数和列数</span></span><br><span class="line">n=ce.shape[<span class="number">0</span>]   <span class="comment"># DataFrame的行数</span></span><br><span class="line">m=ce.shape[<span class="number">1</span>]  <span class="comment"># DataFrame的列数</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-8-设置索引列"><a href="#1-2-8-设置索引列" class="headerlink" title="1.2.8 设置索引列"></a>1.2.8 设置索引列</h3><p>把df中的某一列作为索引，df中该列会删去，成为索引列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">score = np.array([[<span class="number">80</span>, <span class="number">88</span>], [<span class="number">82</span>, <span class="number">81</span>], [<span class="number">84</span>, <span class="number">75</span>], [<span class="number">86</span>, <span class="number">83</span>], [<span class="number">75</span>, <span class="number">81</span>]])</span><br><span class="line">df = pd.DataFrame(score, columns=[<span class="string">'math'</span>,<span class="string">'english'</span>])</span><br><span class="line">df.min()    <span class="comment"># 获取每一列的最小值</span></span><br><span class="line">type(df.min())  <span class="comment"># pandas.core.series.Series</span></span><br><span class="line">df = df.set_index(<span class="string">'math'</span>)   <span class="comment"># math会成为索引列</span></span><br><span class="line">df</span><br></pre></td></tr></table></figure></p>
<h2 id="1-3-统计某一列中不同值和对应的数量-value-counts"><a href="#1-3-统计某一列中不同值和对应的数量-value-counts" class="headerlink" title="1.3 统计某一列中不同值和对应的数量 value_counts()"></a>1.3 统计某一列中不同值和对应的数量 value_counts()</h2><p>class列中总共有3中取值，每一种的数据量都是50.使用value_counts()返回值是pandas.core.series.Series，返回值是已经根据后面的数量进行了排序，默认是从大到小的排序。之后可以通过d.index[0]获取数量最大对应的属性值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">filename = <span class="string">r"C:\others\doc\MachineLearning\data mining\Iris\Iris.csv"</span></span><br><span class="line">df = pd.read_csv(open(filename), delimiter=<span class="string">","</span>)</span><br><span class="line">d = df[<span class="string">'class'</span>].value_counts()</span><br><span class="line">d.index[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iris-versicolor    50</span><br><span class="line">Iris-virginica     50</span><br><span class="line">Iris-setosa        50</span><br><span class="line">Name: class, dtype: int64</span><br><span class="line"></span><br><span class="line">Iris-versicolor</span><br></pre></td></tr></table></figure>
<h2 id="1-4-删除重复数据和写入文件"><a href="#1-4-删除重复数据和写入文件" class="headerlink" title="1.4 删除重复数据和写入文件"></a>1.4 删除重复数据和写入文件</h2><p>drop_duplicate(subset=None, keep=’first’, inplace=False)</p>
<ul>
<li>subset: column label or sequence of labels, optional</li>
<li>keep first, last, False,  删除并保留第一次出现（最后一次出现）的项</li>
<li>inplace  False， True  True表示直接在原来的数据上进行修改 </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除重复数据，根据url列去重，也就是删除url一样的记录</span></span><br><span class="line">dataset.drop_duplicates(<span class="string">'url'</span>, <span class="string">'first'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">print(<span class="string">"数据去重完成"</span>)</span><br><span class="line"><span class="comment"># 写入新的csv文件中</span></span><br><span class="line">dataset.to_csv(write_filename, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">print(<span class="string">"数据写入成功"</span>)</span><br></pre></td></tr></table></figure>
<h1 id="2-pandas的数据结构"><a href="#2-pandas的数据结构" class="headerlink" title="2 pandas的数据结构"></a>2 pandas的数据结构</h1><h2 id="2-1-Series（序列）"><a href="#2-1-Series（序列）" class="headerlink" title="2.1 Series（序列）"></a>2.1 Series（序列）</h2><p>Series是带有标签的一维数组，可以保存任何数据类型（整数，字符串，浮点数，Python对象等）。轴标签统称为索引。创建Series的基本方法是调用：</p>
<pre><code>s = pd.Series(data, index=index)
</code></pre><p>这里，data可以是许多不同的东西：</p>
<ul>
<li>Python dict（字典）</li>
<li>ndarray</li>
<li>标量值（如5）</li>
<li>list</li>
</ul>
<p>传入的索引是轴标签的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时的data是ndarray，索引的长度需要和数据长度相同，如果没有传入索引，会自动创建[0至len(data)-1]长度的索引</span></span><br><span class="line">s = pd.Series(np.random.randn(<span class="number">5</span>), index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>])</span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,np.nan,<span class="number">44</span>,<span class="number">1</span>])</span><br><span class="line">s.index</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Out[4]: </span><br><span class="line">a    0.2735</span><br><span class="line">b    0.6052</span><br><span class="line">c   -0.1692</span><br><span class="line">d    1.8298</span><br><span class="line">e    0.5432</span><br><span class="line">dtype: float64</span><br><span class="line">Out[5]: Index([u&apos;a&apos;, u&apos;b&apos;, u&apos;c&apos;, u&apos;d&apos;, u&apos;e&apos;], dtype=&apos;object&apos;)</span><br></pre></td></tr></table></figure>
<p>使用标量的时候。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series(<span class="number">5</span>, index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>])</span><br><span class="line">s</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Out[10]: </span><br><span class="line">a    5.0</span><br><span class="line">b    5.0</span><br><span class="line">c    5.0</span><br><span class="line">d    5.0</span><br><span class="line">e    5.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>具体使用字典的时候这里就暂时不显示，目前很少用到。</p>
<h3 id="2-1-1-获取元素索引对应的值"><a href="#2-1-1-获取元素索引对应的值" class="headerlink" title="2.1.1 获取元素索引对应的值"></a>2.1.1 获取元素索引对应的值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Series 可以看做一个固定大小的字典，可以通过使用index作为索引来获取和设置值</span></span><br><span class="line">s[<span class="string">'a'</span>]</span><br><span class="line">s[<span class="string">'b'</span>] = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否有e这个索引值</span></span><br><span class="line"><span class="string">'e'</span> <span class="keyword">in</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某个索引的值，有两种方法</span></span><br><span class="line">s[<span class="string">'f'</span>]    <span class="comment"># 若不存在f索引，则会报错</span></span><br><span class="line">s.get(<span class="string">'f'</span>)    <span class="comment"># 若不存在f索引，则会返回None，或者指定默认值</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-运算"><a href="#2-1-2-运算" class="headerlink" title="2.1.2 运算"></a>2.1.2 运算</h3><p>和Numpy数组方法一致，不用一个值一个值遍历序列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series(np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br><span class="line">s+s</span><br><span class="line">s*<span class="number">3</span>   <span class="comment"># 每一个值对应乘三，结果[3,6,9,12,15]</span></span><br><span class="line">np.exp(s)  <span class="comment">#对每一个值求其以e为底的值</span></span><br></pre></td></tr></table></figure></p>
<p>与numpy数组不同的地方在于：Series上的操作会自动根据标签自动对齐数据，比如：可以分别看一下s[1:] 和 s[:-1]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">1</span>:]+s[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0    NaN</span><br><span class="line">1    4.0</span><br><span class="line">2    6.0</span><br><span class="line">3    8.0</span><br><span class="line">4    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h2 id="2-2-DataFrame"><a href="#2-2-DataFrame" class="headerlink" title="2.2 DataFrame"></a>2.2 DataFrame</h2><p>DataFrame是带有标签的二维数据结构，列的类型可能不同，可以想象成一个电子表格或者SQL表。<br>DataFrame是带有标签的二维数据结构，列的类型可能不同。你可以把它想象成一个电子表格或SQL表，或者 Series 对象的字典。它一般是最常用的pandas对象。像 Series 一样，DataFrame 接受许多不同类型的输入：</p>
<ul>
<li>一维数组，列表，字典或 Series 的字典</li>
<li>二维 numpy.ndarray</li>
<li>结构化或记录 ndarray</li>
<li>Series</li>
<li>另一个DataFrame</li>
</ul>
<p>和数据一起，您可以选择传递index（行标签）和columns（列标签）参数。如果传递索引或列，则会用于生成的DataFrame的索引或列。因此，Series 的字典加上特定索引将丢弃所有不匹配传入索引的数据。</p>
<h3 id="2-2-1-使用Series和字典构造df"><a href="#2-2-1-使用Series和字典构造df" class="headerlink" title="2.2.1 使用Series和字典构造df"></a>2.2.1 使用Series和字典构造df</h3><p>index是各种列索引的<strong>并集</strong>，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    <span class="string">'one'</span>: pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]),</span><br><span class="line">    <span class="string">'two'</span>: pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># df = pd.DataFrame(&#123;'time':pd.Series(time), 'count':pd.Series(count)&#125;)</span></span><br><span class="line">df = pd.DataFrame(d, index=[<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'d'</span>])</span><br><span class="line">df = pd.DataFrame(d, index=[<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'d'</span>], columns=[<span class="string">'two'</span>,<span class="string">'three'</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    one	 two</span><br><span class="line">a	1.0	 1</span><br><span class="line">b	2.0	 2</span><br><span class="line">c	3.0	 3</span><br><span class="line">d	NaN	 4</span><br><span class="line"></span><br><span class="line"># 如果在DataFrame中增加了index和columns两个属性，那么在新建对象的时候新增的索引和列会根据Series中的index取</span><br><span class="line">	one	two</span><br><span class="line">c	3.0	3</span><br><span class="line">a	1.0	1</span><br><span class="line">d	NaN	4</span><br><span class="line"></span><br><span class="line">	two	three</span><br><span class="line">c	3	NaN</span><br><span class="line">a	1	NaN</span><br><span class="line">d	4	NaN</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-创建只有列索引的空DataFrame"><a href="#2-2-2-创建只有列索引的空DataFrame" class="headerlink" title="2.2.2 创建只有列索引的空DataFrame"></a>2.2.2 创建只有列索引的空DataFrame</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list_columns = [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'10'</span>, <span class="string">'11'</span>]</span><br><span class="line">df_local = pd.DataFrame(columns=list_columns)    <span class="comment"># 创建一个只有列索引的空数据</span></span><br><span class="line">df_local</span><br></pre></td></tr></table></figure>
<h1 id="3-时间日期的操作"><a href="#3-时间日期的操作" class="headerlink" title="3 时间日期的操作"></a>3 时间日期的操作</h1><h2 id="3-1-转换成时间类型"><a href="#3-1-转换成时间类型" class="headerlink" title="3.1 转换成时间类型"></a>3.1 转换成时间类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将数据类型object转换成日期类型</span></span><br><span class="line">df[<span class="string">'time'</span>] = pd.to_datetime(df[<span class="string">'time'</span>])</span><br></pre></td></tr></table></figure>
<h1 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4 常用方法"></a>4 常用方法</h1><h2 id="4-1-min"><a href="#4-1-min" class="headerlink" title="4.1 min()"></a>4.1 min()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">score = np.array([[<span class="number">80</span>, <span class="number">88</span>], [<span class="number">82</span>, <span class="number">81</span>], [<span class="number">84</span>, <span class="number">75</span>], [<span class="number">86</span>, <span class="number">83</span>], [<span class="number">75</span>, <span class="number">81</span>]])</span><br><span class="line">df = pd.DataFrame(score, columns=[<span class="string">'math'</span>,<span class="string">'english'</span>])</span><br><span class="line">df.min()    <span class="comment"># 获取每一列的最小值</span></span><br><span class="line">type(df.min())  <span class="comment"># pandas.core.series.Series</span></span><br></pre></td></tr></table></figure>
<h2 id="4-2-标准化"><a href="#4-2-标准化" class="headerlink" title="4.2 标准化"></a>4.2 标准化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准化， gray.min()获取的是每一列的最小值  gray——DataFrame结构</span></span><br><span class="line"><span class="comment"># 计算灰色关联分析里面得到的</span></span><br><span class="line">gray=(gray - gray.min()) / (gray.max() - gray.min())</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/18/python3/pandas1/" data-id="cjtinfprq004fxw7744yz1qpb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pandas/">pandas</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python3/PythonSnippets" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/18/python3/PythonSnippets/" class="article-date">
  <time datetime="2018-08-18T07:03:50.000Z" itemprop="datePublished">2018-08-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python3/">python3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/18/python3/PythonSnippets/">python snippets</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1汉字编码-URL编码解码"><a href="#1汉字编码-URL编码解码" class="headerlink" title="1汉字编码 URL编码解码"></a>1汉字编码 URL编码解码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">u'长春疫苗'</span></span><br><span class="line">s_code = s.encode(<span class="string">'UTF-8'</span>)</span><br><span class="line">s_code</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如何对url链接中的汉字编码</span></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">s_code1 = urllib.parse.quote(s)</span><br><span class="line">print(s_code1)</span><br><span class="line">s_code1 = <span class="string">"%25E9%25B9%25BF%25E6%2599%2597"</span></span><br><span class="line">s_code2 = urllib.parse.unquote(s_code1)</span><br><span class="line"><span class="comment"># 解码</span></span><br><span class="line">print(urllib.parse.unquote(s_code2))</span><br></pre></td></tr></table></figure>
<pre><code>%E9%95%BF%E6%98%A5%E7%96%AB%E8%8B%97
鹿晗
</code></pre><h2 id="1-1-python3编码问题"><a href="#1-1-python3编码问题" class="headerlink" title="1.1 python3编码问题"></a>1.1 python3编码问题</h2><p>可以参考这里<a href="https://www.cnblogs.com/575dsj/p/7112767.html" target="_blank" rel="noopener">here</a></p>
<h1 id="2-datetime求时间差"><a href="#2-datetime求时间差" class="headerlink" title="2 datetime求时间差"></a>2 datetime求时间差</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># 使用scrapy爬取数据，最后显示的有开始的时间和结束的时间，但是时间格式如下所示，要求时间差可以使用下面的方式。</span></span><br><span class="line">finish_time = datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">25</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">29</span>, <span class="number">616530</span>)</span><br><span class="line">start_time = datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">25</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">57</span>, <span class="number">580133</span>)</span><br><span class="line">(finish_time-start_time).seconds</span><br></pre></td></tr></table></figure>
<pre><code>32
</code></pre><h1 id="3-python字符串相关"><a href="#3-python字符串相关" class="headerlink" title="3 python字符串相关"></a>3 python字符串相关</h1><p>主要是字符串相关的一些知识点</p>
<ul>
<li>访问字符串的值，字符串拼接，字符串运算</li>
<li>字符串格式化相关</li>
</ul>
<h2 id="3-1-字符串拼接，运算，访问"><a href="#3-1-字符串拼接，运算，访问" class="headerlink" title="3.1 字符串拼接，运算，访问"></a>3.1 字符串拼接，运算，访问</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">"hello world"</span>;  </span><br><span class="line">print(s1[<span class="number">4</span>])   <span class="comment"># 字符串访问</span></span><br><span class="line"></span><br><span class="line">s2 = s1[:<span class="number">6</span>]+<span class="string">"Qiu"</span>;   <span class="comment"># 字符串拼接</span></span><br><span class="line">print(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复输出字符串</span></span><br><span class="line">s3 = s2*<span class="number">3</span>;</span><br><span class="line">print(s3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始字符串：所有的字符串都是直接按照字面意思来使用，没有转移特殊或者不能打印的字符。</span></span><br><span class="line">s4 = <span class="string">r'\n\t\r hello world'</span></span><br><span class="line">print(s4)</span><br></pre></td></tr></table></figure>
<pre><code>o
hello Qiu
hello Qiuhello Qiuhello Qiu
\n\t\r hello world
</code></pre><h2 id="3-2-字符串格式化"><a href="#3-2-字符串格式化" class="headerlink" title="3.2 字符串格式化"></a>3.2 字符串格式化</h2><p>看一些字符串格式化的规则：</p>
<p>%[(name)][flags][width].[precision]typecode</p>
<p>(name)      可选，用于选择指定的key<br>flags          可选，可供选择的值有:</p>
<ul>
<li>+       右对齐；正数前加正好，负数前加负号；</li>
<li>-        左对齐；正数前无符号，负数前加负号；</li>
<li>空格    右对齐；正数前加空格，负数前加负号；  </li>
<li>0        右对齐；正数前无符号，负数前加负号；用0填充空白处  </li>
</ul>
<p>width         可选，占有宽度<br>.precision   可选，小数点后保留的位数  </p>
<h3 id="3-2-1-ASCII-二进制-十进制-八进制-十六进制"><a href="#3-2-1-ASCII-二进制-十进制-八进制-十六进制" class="headerlink" title="3.2.1 ASCII  二进制 十进制 八进制 十六进制"></a>3.2.1 ASCII  二进制 十进制 八进制 十六进制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="number">97</span></span><br><span class="line">c1 = <span class="string">"%c"</span> % d</span><br><span class="line">print(c1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换成二进制，之后可以使用replace替换掉0b</span></span><br><span class="line">c2 = bin(d)</span><br><span class="line">print(c2)</span><br><span class="line"></span><br><span class="line">c3 = <span class="string">"%o"</span> % d;</span><br><span class="line">print(c3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大小写x都行，十六进制</span></span><br><span class="line">c4 = <span class="string">"%X"</span> % d;</span><br><span class="line">print(c4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点数</span></span><br><span class="line">c5 = <span class="string">"%f"</span> % d;</span><br><span class="line">print(c5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 科学计数法</span></span><br><span class="line">c6 = <span class="string">"%e"</span> % d;</span><br><span class="line">print(c6)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据值得大小决定使用%f 还是%e</span></span><br><span class="line">c7 = <span class="string">"%g"</span> % d;</span><br><span class="line">print(c7)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">0b1100001</span><br><span class="line">141</span><br><span class="line">61</span><br><span class="line">97.000000</span><br><span class="line">9.700000e+01</span><br><span class="line">97</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-给变量命名"><a href="#3-2-2-给变量命名" class="headerlink" title="3.2.2 给变量命名"></a>3.2.2 给变量命名</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span>;</span><br><span class="line">name = <span class="string">"Q"</span></span><br><span class="line">greeting = <span class="string">"his name is %(name)s, he is %(age)d years old"</span> % &#123;<span class="string">'name'</span>:name, <span class="string">'age'</span>:age&#125;</span><br><span class="line">print(greeting)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这种既包含命名变量又包含没命名变量就不会了</span></span><br><span class="line"><span class="comment"># greeting1 = "his name is %(name)s, he is %(age)d years old and he is %s " % (&#123;'name':name, 'age':age&#125;, 'yes')</span></span><br></pre></td></tr></table></figure>
<pre><code>his name is Q, he is 18 years old
</code></pre><h3 id="3-2-3-填充0-左右对齐"><a href="#3-2-3-填充0-左右对齐" class="headerlink" title="3.2.3 填充0  左右对齐"></a>3.2.3 填充0  左右对齐</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">1234</span>;</span><br><span class="line"><span class="comment"># 用0填充空白处，此时需要c为int型才有效，如果这里的d换成s，那么不会达到想要的结果</span></span><br><span class="line">c1 = <span class="string">"%010d"</span> % c;</span><br><span class="line">print(c1)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0000001234</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">### 3.2.4 精度</span><br><span class="line">print(&quot;%g&quot; % 23.45676)   %g是5舍6入，同时保留6位数字。在牛客网上做题的时候发现有时候需要保留6位数字，不然不能通过测试用例。</span><br><span class="line">```python</span><br><span class="line">c = 1.234567</span><br><span class="line"></span><br><span class="line"># 保留4位小数</span><br><span class="line">c1 = &quot;%.4f&quot; % c;</span><br><span class="line">print(c1)</span><br><span class="line"></span><br><span class="line"># 保留四位小数，总长度为10,在左侧补0</span><br><span class="line">c2 = &quot;%010.4f&quot; % c</span><br><span class="line">print(c2)</span><br></pre></td></tr></table></figure>
<pre><code>1.2346
00001.2346 看空格
</code></pre><h2 id="3-3-其他"><a href="#3-3-其他" class="headerlink" title="3.3 其他"></a>3.3 其他</h2><ul>
<li>将字符串转换成列表，元组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"1234"</span>;</span><br><span class="line">print(list(s), tuple(s))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;] (&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li>判断字符串是否包含某个子串<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">'12'</span> <span class="keyword">in</span> <span class="string">'123'</span>:</span><br><span class="line">    print(<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure>
<h1 id="4-list"><a href="#4-list" class="headerlink" title="4 list"></a>4 list</h1><h2 id="4-1-获取列表中最大值所在的索引"><a href="#4-1-获取列表中最大值所在的索引" class="headerlink" title="4.1 获取列表中最大值所在的索引"></a>4.1 获取列表中最大值所在的索引</h2><p>index() 函数用于从列表中找出某个值第一个匹配项的索引位置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">counts_baidu = [<span class="number">13879</span>,<span class="number">17886</span>,<span class="number">11305</span>,<span class="number">5961</span>,<span class="number">3086</span>,<span class="number">2331</span>,<span class="number">1680</span>]</span><br><span class="line">max_index = counts_baidu.index(max(counts_baidu))</span><br><span class="line">max_index</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="4-2-del-remove-pop列表元素删除"><a href="#4-2-del-remove-pop列表元素删除" class="headerlink" title="4.2 del  remove pop列表元素删除"></a>4.2 del  remove pop列表元素删除</h2><ul>
<li>remove() 函数用于移除列表中某个值的第一个匹配项。该方法没有返回值，但是会移除列表中第一个匹配项</li>
<li>pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。  </li>
</ul>
<p>需要注意的是删除元素的时候会改变元素在列表中的位置，因此如果是遍历删除的时候需要注意这个问题，可能下一个删除的元素不是自己想要删除的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">l.remove(<span class="number">2</span>)</span><br><span class="line">l.pop(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">del</span> l[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 3, 2, 5]</span><br></pre></td></tr></table></figure>
<h2 id="4-3-list的拷贝问题"><a href="#4-3-list的拷贝问题" class="headerlink" title="4.3 list的拷贝问题"></a>4.3 list的拷贝问题</h2><p>list拷贝存在两种方式，一种是直接赋值，一种是使用切片，具体操作如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'wang'</span>,<span class="string">'lu'</span>,<span class="string">'love'</span>]</span><br><span class="line">b = a</span><br><span class="line">c = a[:]</span><br><span class="line"></span><br><span class="line">a.append(<span class="string">'Qiu'</span>)</span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&apos;wang&apos;, &apos;lu&apos;, &apos;love&apos;, &apos;Qiu&apos;]</span><br><span class="line">[&apos;wang&apos;, &apos;lu&apos;, &apos;love&apos;]</span><br></pre></td></tr></table></figure>
<p>可以发现直接赋值的时候，当原先的列表发生改变的时候，拷贝的列表也会相应的发生变化。但是使用切片的时候就不会了。可以理解为是引用复制和内容复制。</p>
<h2 id="4-4-list一些切片操作"><a href="#4-4-list一些切片操作" class="headerlink" title="4.4 list一些切片操作"></a>4.4 list一些切片操作</h2><p>list[start:end:step]</p>
<ul>
<li>列表元素逆序  a[::-1]，该操作同样适用于字符串，若a=’1234’,a[::-1] = ‘4321’</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'wang'</span>,<span class="string">'lu'</span>,<span class="string">'love'</span>]</span><br><span class="line">a[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">a[::<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">a = <span class="string">'abcde'</span></span><br><span class="line">a[<span class="number">-3</span>:]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&apos;love&apos;, &apos;lu&apos;, &apos;wang&apos;]</span><br><span class="line">[&apos;wang&apos;, &apos;love&apos;]</span><br><span class="line"># e代表-1  d代表-2  c代表-3，因此输出cde</span><br><span class="line">cde</span><br></pre></td></tr></table></figure>
<h2 id="4-5-list遍历"><a href="#4-5-list遍历" class="headerlink" title="4.5 list遍历"></a>4.5 list遍历</h2><p>包含对应元素的索引信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">"Tom"</span>,<span class="string">'Mary'</span>,<span class="string">'Jack'</span>]</span><br><span class="line"><span class="keyword">for</span> i,val <span class="keyword">in</span> enumerate(names):</span><br><span class="line">    print(i,<span class="string">"--"</span>,val)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 -- Tom</span><br><span class="line">1 -- Mary</span><br><span class="line">2 -- Jack</span><br></pre></td></tr></table></figure>
<h2 id="4-6-使用join连接列表元素"><a href="#4-6-使用join连接列表元素" class="headerlink" title="4.6 使用join连接列表元素"></a>4.6 使用join连接列表元素</h2><p>会报错，序列不能使整数，只能是字符串。（S）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">(<span class="string">","</span>).join(a)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: sequence item 0: expected str instance, int found</span><br></pre></td></tr></table></figure>
<h2 id="4-7-list切片生成二维数组"><a href="#4-7-list切片生成二维数组" class="headerlink" title="4.7 list切片生成二维数组"></a>4.7 list切片生成二维数组</h2><p>生成一个二维的数组，全部元素为0<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">arr</span><br></pre></td></tr></table></figure></p>
<h2 id="4-8-删除列表中重复元素并按照原先顺序排序"><a href="#4-8-删除列表中重复元素并按照原先顺序排序" class="headerlink" title="4.8 删除列表中重复元素并按照原先顺序排序"></a>4.8 删除列表中重复元素并按照原先顺序排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">st = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'D'</span>, <span class="string">'S'</span>, <span class="string">'A'</span>]</span><br><span class="line"><span class="comment"># 使用set()可以去重</span></span><br><span class="line">li = list(set(st))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">li.sort(key=st.index)</span><br><span class="line">li</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出</span><br><span class="line">[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;S&apos;]</span><br></pre></td></tr></table></figure>
<h1 id="5-range"><a href="#5-range" class="headerlink" title="5 range"></a>5 range</h1><h2 id="5-1-生成数字列表"><a href="#5-1-生成数字列表" class="headerlink" title="5.1 生成数字列表"></a>5.1 生成数字列表</h2><p>range(start, stop[, step])   注意返回的类型，要想看到输出的结果，可以使用list()，但是在使用的使用，可以不用list()进行转换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c = range(<span class="number">10</span>)</span><br><span class="line">print(type(c))</span><br><span class="line">print(list(c))</span><br><span class="line"></span><br><span class="line">c1 = range(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">print(list(c1))</span><br><span class="line"></span><br><span class="line">c2 = range(<span class="number">1</span>,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">print(list(c2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate a reverse-order list</span></span><br><span class="line">c3 = range(<span class="number">4</span>,<span class="number">0</span>,<span class="number">-1</span>)</span><br><span class="line">print(list(c3))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;range&apos;&gt;</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[1, 3, 5, 7, 9]</span><br><span class="line">[4, 3, 2, 1]</span><br></pre></td></tr></table></figure>
<h2 id="5-2-生成两个参数的for循环"><a href="#5-2-生成两个参数的for循环" class="headerlink" title="5.2 生成两个参数的for循环"></a>5.2 生成两个参数的for循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> zip(range(<span class="number">4</span>), range(<span class="number">4</span>)):</span><br><span class="line">    print(i, <span class="string">", "</span>, j)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出</span><br><span class="line"><span class="number">0</span> ,  <span class="number">0</span></span><br><span class="line"><span class="number">1</span> ,  <span class="number">1</span></span><br><span class="line"><span class="number">2</span> ,  <span class="number">2</span></span><br><span class="line"><span class="number">3</span> ,  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="5-3-生成A-Z-26个英文字母"><a href="#5-3-生成A-Z-26个英文字母" class="headerlink" title="5.3 生成A-Z 26个英文字母"></a>5.3 生成A-Z 26个英文字母</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sl = [chr(i).upper() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">97</span>, <span class="number">123</span>)]</span><br></pre></td></tr></table></figure>
<h1 id="6-zip"><a href="#6-zip" class="headerlink" title="6 zip"></a>6 zip</h1><p>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list_01 = [&apos;Tom&apos;,&apos;mary&apos;]</span><br><span class="line">list_02 = [23,24]</span><br><span class="line">list_03 = [&apos;male&apos;,&apos;female&apos;]</span><br><span class="line">z = zip(list_01, list_02, list_03)</span><br><span class="line">list(z)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(&apos;Tom&apos;, 23, &apos;male&apos;), (&apos;mary&apos;, 24, &apos;female&apos;)]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">zipped = list(zip(a,b))</span><br><span class="line">print(zipped)</span><br><span class="line"></span><br><span class="line">print(list(zip(*zipped)))</span><br></pre></td></tr></table></figure>
<pre><code>[(1, 4), (2, 5), (3, 6)]
[(1, 2, 3), (4, 5, 6)]
</code></pre><h1 id="7-文件操作"><a href="#7-文件操作" class="headerlink" title="7 文件操作"></a>7 文件操作</h1><h2 id="7-1-按行读取文件内容"><a href="#7-1-按行读取文件内容" class="headerlink" title="7.1 按行读取文件内容"></a>7.1 按行读取文件内容</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delete stopwords</span></span><br><span class="line">filepath = <span class="string">r"C:\others\doc\teamAndPersonInfo\研究生\资源库\stopwords\stopwords1.txt"</span></span><br><span class="line"><span class="comment"># read stopwords and create stopword set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_stopwords</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    sw_set = set()</span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># traverse file by line</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            sw_set.add(line.strip(<span class="string">"\n"</span>))</span><br><span class="line">    print(<span class="string">"stopwords set:"</span>,sw_set)</span><br><span class="line">    <span class="keyword">return</span> sw_set</span><br><span class="line">sw_set = read_stopwords(filepath)</span><br></pre></td></tr></table></figure>
<pre><code>stopwords set: {&apos;&apos;, &quot;&apos;&quot;, &apos;:&apos;, &apos;九&apos;, &apos;嗳&apos;, &apos;8&apos;, &apos;5&apos;, &apos;)&apos;, &apos;6&apos;, &apos;％&apos;, &apos;哎呀&apos;, &apos;&quot;&apos;, &apos;——&apos;, &apos;月&apos;, &apos;是&apos;, &apos; ]&apos;, &apos;。&apos;, &apos;啊&apos;, &apos;!&apos;, &apos;￥&apos;, &apos;八&apos;, &apos;&gt;&apos;, &apos;俺们&apos;, &apos;）&apos;, &apos;呗&apos;, &apos;七&apos;, &apos;］&apos;, &apos;＞&apos;, &apos;，&apos;, &apos;唉&apos;, &apos;还&apos;, &apos;哎哟&apos;, &apos;\u3000&apos;, &apos;|&apos;, &apos;７&apos;, &apos;三&apos;, &apos;〉&apos;, &apos;９&apos;, &apos;7&apos;, &apos;＆&apos;, &apos;１&apos;, &apos;４&apos;, &apos;/&apos;, &apos;&amp;&apos;, &apos;3&apos;, &apos;！&apos;, &apos;２&apos;, &apos;＊&apos;, &apos;｛&apos;, &apos;+&apos;, &apos;\\&apos;, &apos;9&apos;, &apos;;&apos;, &apos;：&apos;, &apos;·&apos;, &apos;［&apos;, &apos;嗬&apos;, &apos;＠&apos;, &apos;\ufeff,&apos;, &apos;*&apos;, &apos;向&apos;, &apos;｜&apos;, &apos;’&apos;, &apos;...&apos;, &apos;‘&apos;, &apos;2&apos;, &apos;＜&apos;, &apos;(&apos;, &apos;的&apos;, &apos;0&apos;, &apos;咚&apos;, &apos;—&apos;, &apos;%&apos;, &apos;喏&apos;, &apos;＄&apos;, &apos;很&apos;, &apos;按&apos;, &apos;`&apos;, &apos;嗯&apos;, &apos;在&apos;, &apos;日&apos;, &apos;&gt;&gt;&apos;, &apos;六&apos;, &apos;＃&apos;, &apos;吧哒&apos;, &apos;喔唷&apos;, &apos;=&apos;, &apos;啐&apos;, &apos;；&apos;, &apos;０&apos;, &apos;？&apos;, &apos;.&apos;, &apos;３&apos;, &apos;、&apos;, &apos;五&apos;, &apos;｝&apos;, &apos;～&apos;, &apos;4&apos;, &apos;”&apos;, &apos;》&apos;, &apos;便&apos;, &apos;二&apos;, &apos;@&apos;, &apos;$&apos;, &apos;白&apos;, &apos;_&apos;, &apos;兮&apos;, &apos;..&apos;, &apos;哎&apos;, &apos;８&apos;, &apos;（&apos;, &apos;?&apos;, &apos;&lt;&apos;, &apos;了&apos;, &apos;--&apos;, &apos;给&apos;, &apos;说&apos;, &apos;零&apos;, &apos;＋&apos;, &apos;呃&apos;, &apos;５&apos;, &apos;着&apos;, &apos;俺&apos;, &apos;“&apos;, &apos;#&apos;, &apos;年&apos;, &apos;…&apos;, &apos;按照&apos;, &apos;^&apos;, &apos;和&apos;, &apos;６&apos;, &apos;阿&apos;, &apos;1&apos;, &apos; [&apos;, &apos;A&apos;, &apos;吧&apos;, &apos;《&apos;, &apos;〈&apos;, &apos;到&apos;, &apos;-&apos;, &apos;︿&apos;, &apos;咦&apos;, &apos;尼&apos;, &apos;~&apos;}
</code></pre><h1 id="8-collections"><a href="#8-collections" class="headerlink" title="8 collections"></a>8 collections</h1><h2 id="8-1-collections-defaultdict"><a href="#8-1-collections-defaultdict" class="headerlink" title="8.1 collections.defaultdict"></a>8.1 collections.defaultdict</h2><p>当键的默认值不清楚的时候，可以使用defaultdict，比如下面的这种情况。在key值不存在的时候，默认值为0。<a href="https://blog.csdn.net/the_little_fairy___/article/details/80551538" target="_blank" rel="noopener">参考这里</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">bag = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'cherry'</span>, <span class="string">'apple'</span>,<span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'blueberry'</span>]</span><br><span class="line">count = defaultdict(<span class="keyword">lambda</span>:<span class="number">0</span>)    <span class="comment">#   count = &#123;&#125;;如果这么写，会报错keyerror</span></span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> bag:</span><br><span class="line">    count[fruit] += <span class="number">1</span></span><br><span class="line">count</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;apple&apos;: 3, &apos;blueberry&apos;: 1, &apos;cherry&apos;: 2, &apos;orange&apos;: 1&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="8-2-Counter"><a href="#8-2-Counter" class="headerlink" title="8.2 Counter"></a>8.2 Counter</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">st = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">Counter(st)   <span class="comment"># 统计列表中每个元素的个数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Counter(&#123;0: 1, 1: 2, 2: 4, 3: 1, 4: 2, 5: 3&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> Counter(st).items():</span><br><span class="line">    print(k, v)</span><br></pre></td></tr></table></figure>
<h2 id="8-3-OrderedDict"><a href="#8-3-OrderedDict" class="headerlink" title="8.3 OrderedDict"></a>8.3 OrderedDict</h2><p>普通的dict插入元素时是无序的，使用OrderedDict可以按照元素插入顺序排序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dt = dict()</span><br><span class="line">dt[<span class="string">'k1'</span>] = <span class="string">'v1'</span></span><br><span class="line">dt[<span class="string">'k3'</span>] = <span class="string">'v3'</span></span><br><span class="line">dt[<span class="string">'k2'</span>] = <span class="string">'v2'</span></span><br><span class="line">dt</span><br><span class="line"><span class="comment"># OrderedDict([('k1', 'v1'), ('k3', 'v3'), ('k2', 'v2')])</span></span><br></pre></td></tr></table></figure></p>
<p>我也试着使用dict()创建了一个字典，输出的结果明显和上面的不同，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dt = dict()</span><br><span class="line">dt[<span class="string">'k1'</span>] = <span class="string">'v1'</span></span><br><span class="line">dt[<span class="string">'k3'</span>] = <span class="string">'v3'</span></span><br><span class="line">dt[<span class="string">'k2'</span>] = <span class="string">'v2'</span></span><br><span class="line">dt</span><br><span class="line"><span class="comment"># &#123;'k1': 'v1', 'k2': 'v2', 'k3': 'v3'&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="8-3-itertools排列组合"><a href="#8-3-itertools排列组合" class="headerlink" title="8.3 itertools排列组合"></a>8.3 itertools排列组合</h2><p>itertools.permutations(iterable, r=None) 其中r默认为空，当为空的时候，r的默认值是可迭代对象的长度。返回值是可迭代对象中元素的排列。<br>itertools.combinations(iterable, r)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">l = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>]</span><br><span class="line">temp = itertools.permutations(l, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(list(temp))</span><br><span class="line"></span><br><span class="line">temp = itertools.combinations(l,<span class="number">2</span>)</span><br><span class="line">print(list(temp))</span><br></pre></td></tr></table></figure>
<pre><code>[(&apos;A&apos;, &apos;B&apos;), (&apos;A&apos;, &apos;C&apos;), (&apos;B&apos;, &apos;A&apos;), (&apos;B&apos;, &apos;C&apos;), (&apos;C&apos;, &apos;A&apos;), (&apos;C&apos;, &apos;B&apos;)]
[(&apos;A&apos;, &apos;B&apos;), (&apos;A&apos;, &apos;C&apos;), (&apos;B&apos;, &apos;C&apos;)]
</code></pre><h1 id="9-dict"><a href="#9-dict" class="headerlink" title="9 dict"></a>9 dict</h1><h2 id="9-1-字典排序"><a href="#9-1-字典排序" class="headerlink" title="9.1 字典排序"></a>9.1 字典排序</h2><p>sorted() 函数对所有可迭代的对象进行排序操作。<br>sorted(iterable[, key[, reverse]])<br>参数说明：</p>
<ul>
<li>iterable – 可迭代对象。</li>
<li>key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li>
<li>reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）</li>
</ul>
<p>key是一个函数，用于指定进行比较的参数。对字典进行排序还是推荐先将字典转换成列表(items)，之后再进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top_10_nouns = &#123;<span class="string">'日报'</span>: <span class="number">17</span>, <span class="string">'疫苗'</span>: <span class="number">1405</span>, <span class="string">'记录'</span>: <span class="number">143</span>, <span class="string">'事'</span>: <span class="number">42</span>, <span class="string">'长生'</span>: <span class="number">866</span>, <span class="string">'狂犬'</span>: <span class="number">89</span>, <span class="string">'社会'</span>: <span class="number">26</span>, <span class="string">'声明'</span>: <span class="number">14</span>, <span class="string">'法律责任'</span>: <span class="number">11</span>, <span class="string">'教授'</span>: <span class="number">6</span>, <span class="string">'有效期'</span>: <span class="number">11</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用key进行排序</span></span><br><span class="line">top_5 = sorted(top_10_nouns.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:<span class="number">5</span>]</span><br><span class="line">print(top_5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用key进行排序</span></span><br><span class="line">top_5 = sorted(top_10_nouns, key=top_10_nouns.get, reverse=<span class="literal">True</span>)[:<span class="number">5</span>]</span><br><span class="line">print(top_5)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(&apos;疫苗&apos;, 1405), (&apos;长生&apos;, 866), (&apos;记录&apos;, 143), (&apos;狂犬&apos;, 89), (&apos;事&apos;, 42)]</span><br><span class="line">[&apos;疫苗&apos;, &apos;长生&apos;, &apos;记录&apos;, &apos;狂犬&apos;, &apos;事&apos;]</span><br></pre></td></tr></table></figure>
<p>为什么会出现上面两种不同的结果，这个就不是很清楚。可以这里理解，top_10_nouns是一个字典，遍历的对象是该字典的键，键通过字典的get函数得到值，然后根据值进行排序，至于最后的返回值，因为迭代对象是该字典的键，所以返回的也是键。</p>
<h2 id="9-2-get"><a href="#9-2-get" class="headerlink" title="9.2 get()"></a>9.2 get()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">'name'</span>: <span class="string">'egon'</span>, <span class="string">'price'</span>: <span class="number">100</span>&#125;</span><br><span class="line">d1.get(<span class="string">'name'</span>)</span><br><span class="line">d1.get(<span class="string">'height'</span>, <span class="string">'no such key'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;egon&apos;</span><br><span class="line">&apos;no such key&apos;</span><br></pre></td></tr></table></figure>
<h2 id="9-3-创建字典对象（元组方式）"><a href="#9-3-创建字典对象（元组方式）" class="headerlink" title="9.3 创建字典对象（元组方式）"></a>9.3 创建字典对象（元组方式）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = [(<span class="string">'name'</span>,<span class="string">'Tom'</span>),(<span class="string">'age'</span>,<span class="string">'12'</span>),(<span class="string">'height'</span>,<span class="number">178</span>)]</span><br><span class="line">d = dict(s)</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;age&apos;: &apos;12&apos;, &apos;height&apos;: 178, &apos;name&apos;: &apos;Tom&apos;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="10-lambda"><a href="#10-lambda" class="headerlink" title="10 lambda"></a>10 lambda</h1><p>如果需要，可以查看<a href="http://python.jobbole.com/87848/" target="_blank" rel="noopener">这篇文档</a></p>
<h1 id="11-一些常用的函数"><a href="#11-一些常用的函数" class="headerlink" title="11 一些常用的函数"></a>11 一些常用的函数</h1><h2 id="11-1-max-min-sort"><a href="#11-1-max-min-sort" class="headerlink" title="11.1 max()/min()  sort()"></a>11.1 max()/min()  sort()</h2><p>max(iterable, key, default)求迭代器的最大值，其中iterable为迭代器，key指定排序规则，key参数是一个可以调用的对象，在Python中，类、自定义函数、内置函数、lambda表达式、带有特殊方法_call__()的对象都属于可以条用的函数。将迭代器函数中每一个返回值作为参数传给key=func中的func，然后func将执行结果返回给key，之后再根据key为标准进行大小的判断。<br>下面以一些实际的例子说明，同时对于sort()  sorted()函数中也存在key这个参数。sort()函数没有返回值，会对列表对象进行排序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="number">11</span>, <span class="number">9</span>, <span class="number">23</span>)</span><br><span class="line">print(max(x))</span><br><span class="line">print(max(x, key=str))   <span class="comment"># 将可迭代对象中的每一项编程字符串之后在进行比较</span></span><br><span class="line"></span><br><span class="line">d1 = &#123;<span class="string">'name'</span>: <span class="string">'egon'</span>, <span class="string">'price'</span>: <span class="number">100</span>&#125;</span><br><span class="line">d2 = &#123;<span class="string">'name'</span>: <span class="string">'rdw'</span>, <span class="string">'price'</span>: <span class="number">666</span>&#125;</span><br><span class="line">d3 = &#123;<span class="string">'name'</span>: <span class="string">'zat'</span>, <span class="string">'price'</span>: <span class="number">1</span>&#125;</span><br><span class="line">l1 = [d1, d2, d3]</span><br><span class="line">a = max(l1, key=<span class="keyword">lambda</span> x: x[<span class="string">'name'</span>])</span><br><span class="line">print(a)</span><br><span class="line">b = max(l1, key=<span class="keyword">lambda</span> x: x[<span class="string">'price'</span>])</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'zat'</span>, <span class="string">'price'</span>: <span class="number">1</span>&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'rdw'</span>, <span class="string">'price'</span>: <span class="number">666</span>&#125;</span><br></pre></td></tr></table></figure>
<p>sort() 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。该方法没有返回值，但是会对列表的对象进行排序。</p>
<h2 id="11-2-ord-chr"><a href="#11-2-ord-chr" class="headerlink" title="11.2 ord() chr()"></a>11.2 ord() chr()</h2><p>ord() 参数是unicode字符串，返回的是该unicode字符对应的整数<br>chr()刚好是ord的反函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ord(<span class="string">'a'</span>)</span><br><span class="line">chr(<span class="number">20013</span>)</span><br><span class="line">ord(<span class="string">'中'</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">97</span><br><span class="line">中</span><br><span class="line">20013</span><br></pre></td></tr></table></figure>
<h2 id="11-3-lower-upper-capitalize-title"><a href="#11-3-lower-upper-capitalize-title" class="headerlink" title="11.3  lower()  upper()  capitalize()  title()"></a>11.3  lower()  upper()  capitalize()  title()</h2><ul>
<li>upper()字符串中字母由小写变为大写</li>
<li>lower()字符串中字母由大写变为小写</li>
<li>capitalize()字符串中字母首字母大写其余小写(如果有多个单词，那么只有第一个单词的字母大写，注意与title的区别)</li>
<li>title()字符串中字母每个单词的首字母大写其余小写</li>
</ul>
<p>判断字符串是否为数字或者字母</p>
<ul>
<li>str.isalnum() 所有字符都是数字或者字母</li>
<li>str.isalpha() 所有字符都是字母 </li>
<li>str.isdigit() 所有字符都是数字 </li>
<li>str.islower() 所有字符都是小写 </li>
<li>str.isupper() 所有字符都是大写 </li>
<li>str.istitle() 所有单词都是首字母大写</li>
<li>str.isspace() 所有字符都是空白字符、\t、\n、\r</li>
</ul>
<h2 id="11-4-map"><a href="#11-4-map" class="headerlink" title="11.4 map()"></a>11.4 map()</h2><p>map(func, seq1[, seq2,…])<br>第一个参数接受一个函数名，后面的参数接受一个或多个可迭代的序列，返回的是一个集合。<br>Python函数编程中的map()函数是将func作用于seq中的每一个元素，并将所有的调用的结果作为一个list返回。如果func为None，作用同zip()。<br>1 当只有一个seq的时候，将func作用在每一个元素上，然后返回得到一个新的序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list(map(<span class="keyword">lambda</span> x: x%<span class="number">2</span>, range(<span class="number">7</span>)))</span><br><span class="line"><span class="comment"># 使用列表解析式也可以达到这种效果</span></span><br><span class="line">[item % <span class="number">2</span> <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">7</span>)]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 0, 1, 0, 1, 0]</span><br></pre></td></tr></table></figure>
<p>2 当存在多个seq的时候，map可以并行的处理，也就是将seq中同一位置的元素调去执行函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(list(map(<span class="keyword">lambda</span> x, y: x*y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])))</span><br><span class="line">print(list(map(<span class="keyword">lambda</span> x, y: [x,y], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])))</span><br><span class="line">print(list(zip([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[4, 10, 18]</span><br><span class="line">[[1, 4], [2, 5], [3, 6]]</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br></pre></td></tr></table></figure>
<h1 id="12-进制转换"><a href="#12-进制转换" class="headerlink" title="12 进制转换"></a>12 进制转换</h1><p>十进制数转换成对应的二、八、十六进制可以采用函数  bin()  oct()   hex()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">21</span></span><br><span class="line">print(bin(a))</span><br><span class="line">print(oct(a))</span><br><span class="line">print(hex(a))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0b10101</span><br><span class="line">0o25</span><br><span class="line">0x15</span><br></pre></td></tr></table></figure>
<p>如果是对应的进制转换成十进制，使用int(s,decimal=2,8,16),第一个参数是数字字符串，后面的是该字符串对应的进制。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'f'</span></span><br><span class="line">int(a,<span class="number">16</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>
<p>也就是将a看做是16进制的数，使用int()转换成十进制数时的值。</p>
<h1 id="13-使用Pdb进行python调试"><a href="#13-使用Pdb进行python调试" class="headerlink" title="13 使用Pdb进行python调试"></a>13 使用Pdb进行python调试</h1><p>参考链接<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/" target="_blank" rel="noopener">here</a></p>
<ul>
<li>set_trace()</li>
<li>n </li>
<li>q 退出 debug：使用 quit 或者 q 可以退出当前的 debug，但是 quit 会以一种非常粗鲁的方式退出程序，其结果是直接 crash。</li>
<li>p</li>
<li>c</li>
<li>l</li>
<li>s r</li>
<li>!</li>
</ul>
<h2 id="13-1-set-trace"><a href="#13-1-set-trace" class="headerlink" title="13.1 set_trace()"></a>13.1 set_trace()</h2><p>下面以一个例子进行说明，有时候会遇到这种情形，就是在i的取值比较小的时候看不出问题，但是当取值为3或者其他数字的时候才发现问题，为了一步步调试i为3的时候的情形，往往需要将i从0调试开始，如果函数中存在循环，那么一步步的跳到i=3的时候需要点击很多次。而使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if i == 2:</span><br><span class="line">       pdb.set_trace()</span><br></pre></td></tr></table></figure></p>
<p>可以在i==2的时候，就会指定pdb.set_trace()，程序就会停下来，之后就会在控制台看到如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\14259\Anaconda3\python.exe C:/others/CODING/python/NiuKeWang/201810/N-Queens-Non-Recursion-01.py</span><br><span class="line">&gt; c:\others\coding\python\niukewang\201810\n-queens-non-recursion-01.py(45)Queue()</span><br><span class="line">-&gt; break</span><br><span class="line">(Pdb)</span><br></pre></td></tr></table></figure></p>
<h2 id="13-2-n-p"><a href="#13-2-n-p" class="headerlink" title="13.2 n p"></a>13.2 n p</h2><p>此时可以输入 n然后回车，就会接着向下执行一句，之后再想执行下一句直接按enter就可以了。<br>使用q可以退出当前debug<br>如果需要查看某个变量的值，可以使用 p+变量名字就可以了，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; c:\others\coding\python\niukewang\201810\n-queens-non-recursion-01.py(45)Queue()</span><br><span class="line">-&gt; break</span><br><span class="line">(Pdb) n</span><br><span class="line">&gt; c:\others\coding\python\niukewang\201810\n-queens-non-recursion-01.py(47)Queue()</span><br><span class="line">-&gt; if flag:</span><br><span class="line">(Pdb) flag</span><br><span class="line">True</span><br><span class="line">(Pdb) p flag</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line"># 查看多个变量的值。</span><br><span class="line">(Pdb) p (i,j,mp)</span><br><span class="line">(0, 1, [[&apos;.&apos;, &apos;#&apos;, &apos;#&apos;], [&apos;#&apos;, &apos;.&apos;, &apos;.&apos;], [&apos;.&apos;, &apos;.&apos;, &apos;.&apos;]])</span><br></pre></td></tr></table></figure></p>
<h2 id="13-3-c"><a href="#13-3-c" class="headerlink" title="13.3 c"></a>13.3 c</h2><p>之后可以使用c，然后就会停止当前的debug然后让程序继续执行直到第二个set_trace()或者直到程序结束。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">global</span> count</span><br><span class="line">q = [<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">mm = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; n:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">        pdb.set_trace()</span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(q[i]+<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> mp[i][j] == <span class="string">'#'</span> <span class="keyword">and</span> is_correct(i, j):</span><br><span class="line">            mp[i][j] = <span class="number">1</span></span><br><span class="line">            q[i] = j</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            mm += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mm == <span class="number">2</span>:</span><br><span class="line">                pdb.set_trace()</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="13-4-l"><a href="#13-4-l" class="headerlink" title="13.4 l"></a>13.4 l</h2><p>显示代码：在 debug 的时候不一定能记住当前的代码块，如要要查看具体的代码块，则可以通过使用 list 或者 l 命令显示。list 会用箭头 -&gt; 指向当前 debug 的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(Pdb) l</span><br><span class="line"> 42  	                mm += 1</span><br><span class="line"> 43  	                if mm == 2:</span><br><span class="line"> 44  	                    pdb.set_trace()</span><br><span class="line"> 45  	                break</span><br><span class="line"> 46  	</span><br><span class="line"> 47  -&gt;	        if flag:</span><br><span class="line"> 48  	            if mm == k:</span><br><span class="line"> 49  	                print(mp)</span><br><span class="line"> 50  	                for i in range(n):</span><br><span class="line"> 51  	                    for j in range(n):</span><br><span class="line"> 52  	                        if mp[i][j] == 1:</span><br><span class="line">(Pdb)</span><br></pre></td></tr></table></figure></p>
<p>【注意】<br>下面这里显示for j in range(q[i]+1, n)表示的是该执行此句话，还没有执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\14259\Anaconda3\python.exe C:/others/CODING/python/NiuKeWang/201810/N-Queens-Non-Recursion-01.py</span><br><span class="line">&gt; c:\others\coding\python\niukewang\201810\n-queens-non-recursion-01.py(36)Queue()</span><br><span class="line">-&gt; for j in range(q[i]+1, n):</span><br><span class="line">(Pdb) p j</span><br><span class="line">*** NameError: name &apos;j&apos; is not defined</span><br><span class="line"></span><br><span class="line"># 这样j的值才对</span><br><span class="line">&gt; c:\others\coding\python\niukewang\201810\n-queens-non-recursion-01.py(36)Queue()</span><br><span class="line">-&gt; for j in range(q[i]+1, n):</span><br><span class="line">(Pdb) p j</span><br><span class="line">*** NameError: name &apos;j&apos; is not defined</span><br><span class="line">(Pdb) n</span><br><span class="line">&gt; c:\others\coding\python\niukewang\201810\n-queens-non-recursion-01.py(37)Queue()</span><br><span class="line">-&gt; if mp[i][j] == &apos;#&apos; and is_correct(i, j):</span><br><span class="line">(Pdb) p j</span><br><span class="line">0</span><br><span class="line">(Pdb)</span><br></pre></td></tr></table></figure></p>
<h2 id="13-5-s"><a href="#13-5-s" class="headerlink" title="13.5 s"></a>13.5 s</h2><p>执行函数里面的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 该执行if语句，此时输入s然后回车，就会进入函数里面执行。之后输入r可以直接到函数的return语句，返回到调用位置。</span><br><span class="line">-&gt; if mp[i][j] == &apos;#&apos; and is_correct(i, j):</span><br><span class="line">(Pdb) p i j</span><br><span class="line">*** SyntaxError: unexpected EOF while parsing</span><br><span class="line">(Pdb) p (i,j,mp)</span><br><span class="line">(0, 1, [[&apos;.&apos;, &apos;#&apos;, &apos;#&apos;], [&apos;#&apos;, &apos;.&apos;, &apos;.&apos;], [&apos;.&apos;, &apos;.&apos;, &apos;.&apos;]])</span><br><span class="line">(Pdb) s </span><br><span class="line">--Call--</span><br><span class="line">&gt; c:\others\coding\python\niukewang\201810\n-queens-non-recursion-01.py(12)is_correct()</span><br><span class="line">-&gt; def is_correct(i, j):</span><br><span class="line">(Pdb) r</span><br><span class="line">-&gt; return True</span><br><span class="line">(Pdb)</span><br></pre></td></tr></table></figure></p>
<h2 id="13-6"><a href="#13-6" class="headerlink" title="13.6 !"></a>13.6 !</h2><p>调试的时候动态改变值在调试的时候动态改变值 。在调试的时候可以动态改变变量的值，具体如下实例。需要注意的是下面有个错误，原因是 b 已经被赋值了，如果想重新改变 b 的赋值，则应该使用!b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-&gt; mp[i][j] = 1</span><br><span class="line">(Pdb) str = &quot;test&quot;</span><br><span class="line">(Pdb) p str</span><br><span class="line"></span><br><span class="line"># 变量i已经在函数中被赋值了。</span><br><span class="line">(Pdb) !i =3</span><br><span class="line">(Pdb) p i</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h2 id="13-7-断言调试"><a href="#13-7-断言调试" class="headerlink" title="13.7 断言调试"></a>13.7 断言调试</h2><p>如果断言失败，assert本身就会抛出AssertionError错误<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></span><br><span class="line">    n = int(s)</span><br><span class="line">    <span class="keyword">assert</span> n!=<span class="number">0</span>, <span class="string">'n is zero'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / int(s)</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'0'</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">raceback (most recent call last):</span><br><span class="line">  File &quot;C:/others/CODING/python/week7/day5/mm.py&quot;, line 6, in &lt;module&gt;</span><br><span class="line">    foo(&apos;0&apos;)</span><br><span class="line">  File &quot;C:/others/CODING/python/week7/day5/mm.py&quot;, line 3, in foo</span><br><span class="line">    assert n!=0, &apos;n is zero&apos;</span><br><span class="line">AssertionError: n is zero</span><br></pre></td></tr></table></figure>
<h1 id="14-python的错误处理机制"><a href="#14-python的错误处理机制" class="headerlink" title="14 python的错误处理机制"></a>14 python的错误处理机制</h1><p>异常类的继承关系<a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">here</a>  </p>
<h2 id="14-1-调用栈"><a href="#14-1-调用栈" class="headerlink" title="14.1 调用栈"></a>14.1 调用栈</h2><p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。来看看err.py：<br>如下面这个简单的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># err.py:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / int(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    bar(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:/others/CODING/python/week7/day5/mm.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;C:/others/CODING/python/week7/day5/mm.py&quot;, line 9, in main</span><br><span class="line">    bar(&apos;0&apos;)</span><br><span class="line">  File &quot;C:/others/CODING/python/week7/day5/mm.py&quot;, line 6, in bar</span><br><span class="line">    return foo(s) * 2</span><br><span class="line">  File &quot;C:/others/CODING/python/week7/day5/mm.py&quot;, line 3, in foo</span><br><span class="line">    return 10 / int(s)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<p>出错并不可怕，关键是需要解读错误信息，定位错误位置。从上往下可以看到整个错误的调用函数链。最后面一句是错误产生的源头，之后分析错误类型。<br>详细的分析可以参考廖雪峰老师的Python3<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143191375461417a222c54b7e4d65b258f491c093a515000" target="_blank" rel="noopener">here</a><br>【注意】出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。</p>
<h2 id="14-2-打印错误日志信息logging"><a href="#14-2-打印错误日志信息logging" class="headerlink" title="14.2 打印错误日志信息logging"></a>14.2 打印错误日志信息logging</h2><p>让程序可以在遇到错误的时候继续执行下去，并把错误堆栈打印出来，然后分析原因。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / int(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bar(<span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.exception(e)</span><br><span class="line">main()</span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure></p>
<p>当然也可以配置，让logging把错误日志记录到日志文件中，便于之后查阅。这里暂时不赘述。</p>
<h1 id="15-logging"><a href="#15-logging" class="headerlink" title="15 logging"></a>15 logging</h1><p>参考<a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c13/p11_add_logging_to_simple_scripts.html" target="_blank" rel="noopener">here</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Configure the logging system</span></span><br><span class="line">    logging.basicConfig(</span><br><span class="line">     filename=<span class="string">'app.log'</span>,</span><br><span class="line">     level=logging.WARNING,</span><br><span class="line">     format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Variables (to make the calls that follow work)</span></span><br><span class="line">    hostname = <span class="string">'www.python.org'</span></span><br><span class="line">    item = <span class="string">'spam'</span></span><br><span class="line">    filename = <span class="string">'data.csv'</span></span><br><span class="line">    mode = <span class="string">'r'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Example logging calls (insert into your program)</span></span><br><span class="line">    logging.critical(<span class="string">'Host %s unknown'</span>, hostname)</span><br><span class="line">    logging.error(<span class="string">"Couldn't find %r"</span>, item)</span><br><span class="line">    logging.warning(<span class="string">'Feature is deprecated'</span>)</span><br><span class="line">    logging.info(<span class="string">'Opening file %r, mode=%r'</span>, filename, mode)</span><br><span class="line">    logging.debug(<span class="string">'Got here'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【文件中的输出如下：】</span><br><span class="line">2018-11-19 21:32:54,347 mm.py[line:17] Host www.python.org unknown</span><br><span class="line">2018-11-19 21:32:54,348 mm.py[line:18] Couldn&apos;t find &apos;spam&apos;</span><br><span class="line">2018-11-19 21:32:54,348 mm.py[line:19] Feature is deprecated</span><br></pre></td></tr></table></figure>
<p>上面五个日志调用（critical(), error(), warning(), info(), debug()）以降序方式表示不同的严重级别。 basicConfig() 的 level 参数是一个过滤器。 所有级别低于此级别的日志消息都会被忽略掉。 每个logging操作的参数是一个消息字符串，后面再跟一个或多个参数。 构造最终的日志消息的时候我们使用了%操作符来格式化消息字符串。在basicConfig中可以配置日志输出的路径和level。</p>
<p>上面的日志配置都是硬编码到程序中的。如果你想使用配置文件， 可以像下面这样修改 basicConfig() 调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line">logging.config.fileConfig(<span class="string">'logconfig.ini'</span>)</span><br></pre></td></tr></table></figure></p>
<p>创建一个下面这样的文件，名字叫做 logconfig.ini<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[loggers]</span><br><span class="line">keys=root</span><br><span class="line"></span><br><span class="line">[handlers]</span><br><span class="line">keys=defaultHandler</span><br><span class="line"></span><br><span class="line">[formatters]</span><br><span class="line">keys=defaultFormatter</span><br><span class="line"></span><br><span class="line">[logger_root]</span><br><span class="line">level=INFO</span><br><span class="line">handlers=defaultHandler</span><br><span class="line">qualname=root</span><br><span class="line"></span><br><span class="line">[handler_defaultHandler]</span><br><span class="line">class=FileHandler</span><br><span class="line">formatter=defaultFormatter</span><br><span class="line">args=(<span class="string">'app.log'</span>, <span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">[formatter_defaultFormatter]</span><br><span class="line">format=%(asctime)s %(filename)s[line:%(lineno)d] %(message)s</span><br></pre></td></tr></table></figure></p>
<h1 id="16-json"><a href="#16-json" class="headerlink" title="16 json"></a>16 json</h1><p>因为为了更好的传输中文，json进行了Unicode编码，因此会发现json数据格式中的中文是unicode编码，可以使用loads()方法转化成对应的Python数据结构，对应的中文Unicode编码也转换成了中文字符串。  </p>
<ul>
<li>json.loads()将json编码的数据格式转换成python数据结构。对数据进行解码。</li>
<li>json.dumps()将python数据结构转化成json格式数据。对数据进行编码。<br>在使用json.dumps时要注意一个问题</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"> <span class="keyword">print</span> json.dumps(<span class="string">'中国'</span>)</span><br><span class="line"><span class="comment"># "\u4e2d\u56fd"</span></span><br></pre></td></tr></table></figure>
<p>输出的会是<br>‘中国’ 中的ascii 字符码，而不是真正的中文。</p>
<p>这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> json.dumps(<span class="string">'中国'</span>,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># "中国"</span></span><br></pre></td></tr></table></figure>
<h1 id="17-time"><a href="#17-time" class="headerlink" title="17 time"></a>17 time</h1><h2 id="17-1-strptime"><a href="#17-1-strptime" class="headerlink" title="17.1 strptime()"></a>17.1 strptime()</h2><p>函数根据指定的格式把一个事件字符串解析为时间元组。time.strptime(string[, format])</p>
<ul>
<li>string 事件字符串</li>
<li>format 格式化字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">python中时间日期格式化符号：（来自菜鸟教程）</span><br><span class="line">%y 两位数的年份表示（00-99）</span><br><span class="line">%Y 四位数的年份表示（000-9999）</span><br><span class="line">%m 月份（01-12）</span><br><span class="line">%d 月内中的一天（0-31）</span><br><span class="line">%H 24小时制小时数（0-23）</span><br><span class="line">%I 12小时制小时数（01-12）</span><br><span class="line">%M 分钟数（00=59）</span><br><span class="line">%S 秒（00-59）</span><br><span class="line">%a 本地简化星期名称</span><br><span class="line">%A 本地完整星期名称</span><br><span class="line">%b 本地简化的月份名称</span><br><span class="line">%B 本地完整的月份名称</span><br><span class="line">%c 本地相应的日期表示和时间表示</span><br><span class="line">%j 年内的一天（001-366）</span><br><span class="line">%p 本地A.M.或P.M.的等价符</span><br><span class="line">%U 一年中的星期数（00-53）星期天为星期的开始</span><br><span class="line">%w 星期（0-6），星期天为星期的开始</span><br><span class="line">%W 一年中的星期数（00-53）星期一为星期的开始</span><br><span class="line">%x 本地相应的日期表示</span><br><span class="line">%X 本地相应的时间表示</span><br><span class="line">%Z 当前时区的名称</span><br><span class="line">%% %号本身</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意这里时区使用小写z，大写会出现错误，不知道为啥。</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">str_time = <span class="string">'Tue Aug 08 21:28:36 +0800 2017'</span></span><br><span class="line">res = time.strptime(str_time, <span class="string">'%a %b %d %H:%M:%S %z %Y'</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.struct_time(tm_year=2017, tm_mon=8, tm_mday=8, tm_hour=21, tm_min=28, tm_sec=36, tm_wday=1, tm_yday=220, tm_isdst=-1)</span><br></pre></td></tr></table></figure>
<h2 id="17-2-strftime"><a href="#17-2-strftime" class="headerlink" title="17.2 strftime()"></a>17.2 strftime()</h2><p>与strptime一起使用，可以将时间格式转换成自己想要的事件格式。<br>接受时间元组，返回可读字符串表示的当地事件，格式有参数format确定time.strftime(format [, t])</p>
<ul>
<li>t 可选的参数t是一个struct_time对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = time.strftime(<span class="string">'%Y-%m-%d'</span>, res)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#输出  2017-08-08</span></span><br></pre></td></tr></table></figure>
<h1 id="一些零散的小知识"><a href="#一些零散的小知识" class="headerlink" title="一些零散的小知识"></a>一些零散的小知识</h1><h2 id="1-无穷大和无穷小"><a href="#1-无穷大和无穷小" class="headerlink" title="1 无穷大和无穷小"></a>1 无穷大和无穷小</h2><p>无穷大(小)与一个数的和仍然是无穷大(小)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = float(<span class="string">'-inf'</span>)</span><br><span class="line">b = float(<span class="string">'inf'</span>)</span><br><span class="line">a+<span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-inf</span><br></pre></td></tr></table></figure>
<h2 id="2-input"><a href="#2-input" class="headerlink" title="2 input"></a>2 input</h2><p>input()接受的字符串是原生字符串，就是如果是包含一些转义字符，如\n，那么字符串依然是\n，而不会是换行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/18/python3/PythonSnippets/" data-id="cjtinfpso005rxw77vqudz3af" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/snippets/">snippets</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MachineLearningAndDataMining/标准BP算法Python实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/15/MachineLearningAndDataMining/标准BP算法Python实现/" class="article-date">
  <time datetime="2018-08-15T09:11:51.000Z" itemprop="datePublished">2018-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据挖掘/">数据挖掘</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/15/MachineLearningAndDataMining/标准BP算法Python实现/">标准BP算法Python实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>根据机器学习-周志华书上讲解的BP算法的思想，使用西瓜数据集进行代码实现</p>
<h1 id="1-数据集"><a href="#1-数据集" class="headerlink" title="1 数据集"></a>1 数据集</h1><p>西瓜数据集内容如下图所示：<br><img src="/images/DataMiningTheory/BP/BP_01.png" width="600px" height="100px"></p>
<p>接着是导入数据集并对数据集进行分析和处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">filename = <span class="string">r"C:\Users\14259\Desktop\25周\watermelon.csv"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataset</span><span class="params">(filename)</span>:</span></span><br><span class="line">        csv_reader = csv.reader(open(filename));</span><br><span class="line">        dataset = list(csv_reader);</span><br><span class="line">        <span class="keyword">return</span> dataset[<span class="number">1</span>:]</span><br><span class="line">dataset = loadDataset(filename)</span><br></pre></td></tr></table></figure>
<p>因为数据集中既包含连续变量，也包含离散变量。需要对离散属性进行处理，如果属性值之间存在“序”的关系则可以进行连续化；否则通常转化为K维向量，k为属性值数。参考本书的3.2节。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过代码实现将离散变量转化成k维向量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSingleAttrVector</span><span class="params">(attr_list)</span>:</span></span><br><span class="line">    <span class="string">"""将单列属性的值进行转换成向量，attr_list是属性列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    attrs = list(set(attr_list));  <span class="comment"># 属性取值集合</span></span><br><span class="line">    attr_len = len(attrs);    <span class="comment"># 属性取值的个数</span></span><br><span class="line">    attr_map = collections.defaultdict()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(attrs)):</span><br><span class="line">        temp =<span class="string">"&#123;0:0&#123;attr_len&#125;b&#125;"</span>.format(int(math.pow(<span class="number">2</span>,i)),attr_len = attr_len)   <span class="comment"># 得到对应属性的二进制字符串</span></span><br><span class="line">        <span class="comment"># 对字符串进行切割，形成列表</span></span><br><span class="line">        attr_map[attrs[i]] =[int(i) <span class="keyword">for</span> i <span class="keyword">in</span> tuple(temp)]</span><br><span class="line">        </span><br><span class="line">    attr_lists = [];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(attr_list)):</span><br><span class="line">        attr_lists.append(attr_map[attr_list[i]])</span><br><span class="line">    <span class="keyword">return</span> attr_map,attr_lists    <span class="comment"># 得到对应的向量编码对应列表和相连编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># attr_list = list(zip(*dataset))[1];</span></span><br><span class="line"><span class="comment"># getSingleAttrVector(attr_list)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将数据集中所有的离散变量进行编码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllAttrVector</span><span class="params">(dataset, discrete_index)</span>:</span></span><br><span class="line">    <span class="string">""" dataset数据集，discrete_index离散属性列所在的索引。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    dataset_copy = list(zip(* copy.deepcopy(dataset)));</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> discrete_index:</span><br><span class="line">        attr_list = dataset_copy[i];</span><br><span class="line">        dataset_copy[i] = getSingleAttrVector(attr_list)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> list(zip(*dataset_copy))</span><br></pre></td></tr></table></figure>
<h2 id="1-1-使用numpy-pandas-数据预处理"><a href="#1-1-使用numpy-pandas-数据预处理" class="headerlink" title="1.1 使用numpy pandas 数据预处理"></a>1.1 使用numpy pandas 数据预处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">filename = <span class="string">"C:/Users/14259/Desktop/25周/watermelon.csv"</span></span><br></pre></td></tr></table></figure>
<p>考虑到离散特征的取值之间没有大小的意义，可以使用ont-hot编码。如果离散数值的取值有大小的意义，就使用数值进行映射。<br><a href="https://blog.csdn.net/pipisorry/article/details/61193868" target="_blank" rel="noopener">ont-hot</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(open(filename), delimiter=<span class="string">","</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocessData</span><span class="params">(dataset)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 删除编号列</span></span><br><span class="line">    x = [<span class="number">0</span>]   </span><br><span class="line">    dataset.drop(dataset.columns[x], axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#  对标签列进行映射</span></span><br><span class="line">    temp = [];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dataset.iloc[:,<span class="number">-1</span>])):</span><br><span class="line">        <span class="keyword">if</span> dataset.iloc[:,<span class="number">-1</span>][i].strip() == <span class="string">'是'</span>:</span><br><span class="line">             temp.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">             temp.append(<span class="number">0</span>);</span><br><span class="line">    dataset.iloc[:,<span class="number">-1</span>] = temp</span><br><span class="line">    </span><br><span class="line"><span class="comment">#     print(type(dataset))</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将lable标签单独删除并保存</span></span><br><span class="line">    labels = dataset[dataset.columns[<span class="number">-1</span>]]</span><br><span class="line"><span class="comment">#     print(labels)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#  删除标签列</span></span><br><span class="line">    x = [<span class="number">8</span>]   </span><br><span class="line">    dataset.drop(dataset.columns[x], axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#     print(dataset)</span></span><br><span class="line">    columns = dataset.columns[<span class="number">0</span>:<span class="number">6</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对指定列进行ont-hot编码</span></span><br><span class="line">    dataset = pd.get_dummies(dataset, columns=columns);</span><br><span class="line">    <span class="keyword">return</span> dataset,labels;</span><br><span class="line"><span class="comment"># dataset,labels = preprocessData(dataset)</span></span><br><span class="line"><span class="comment"># 划分成训练集和验证集</span></span><br><span class="line"><span class="comment"># trainSet,validSet = dataset[:15],dataset[15:]</span></span><br><span class="line"><span class="comment"># trainSet</span></span><br></pre></td></tr></table></figure>
<h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h1><h2 id="2-1-定义各种参数"><a href="#2-1-定义各种参数" class="headerlink" title="2.1 定义各种参数"></a>2.1 定义各种参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">input_nodes = dataset.shape[<span class="number">1</span>]</span><br><span class="line">output_nodes = <span class="number">1</span></span><br><span class="line">hidden_nodes = <span class="number">10</span>    <span class="comment"># 隐藏层个数</span></span><br><span class="line"></span><br><span class="line">learning_rate = <span class="number">0.001</span></span><br><span class="line">epochs = <span class="number">1000</span>     <span class="comment"># 迭代次数</span></span><br><span class="line">batch_size = <span class="number">1</span>     <span class="comment"># 每一次处理数据的大小</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-激活函数"><a href="#2-2-激活函数" class="headerlink" title="2.2 激活函数"></a>2.2 激活函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(inx)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1.0</span>+math.exp(-inx))</span><br></pre></td></tr></table></figure>
<h2 id="2-3-随机生成权重和阈值"><a href="#2-3-随机生成权重和阈值" class="headerlink" title="2.3 随机生成权重和阈值"></a>2.3 随机生成权重和阈值</h2><p>在0-1范围内初始化所有连接权和阈值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机生成输入层到隐藏层，隐藏层到输出层之间的权重，还有隐藏层神经元和输出层神经元的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getWeights</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""np.random.normal方法的使用可以参考官方文档，最后一个参数就是制定size的，如果以元组的形式，那么得到的size就是元组内的数值乘积"""</span></span><br><span class="line">    <span class="comment"># 产生0-1内的随机数，同时注意对应的数组形式。</span></span><br><span class="line">    weights_input_hidden = np.random.sample((input_nodes,hidden_nodes))</span><br><span class="line">    weights_hidden_output = np.random.sample( (hidden_nodes, output_nodes))</span><br><span class="line">    </span><br><span class="line">    threshold_hidden = np.random.random(hidden_nodes)</span><br><span class="line">    threshold_output = np.random.random(output_nodes)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> weights_input_hidden,weights_hidden_output,threshold_hidden, threshold_output</span><br></pre></td></tr></table></figure>
<h2 id="2-4-计算输出"><a href="#2-4-计算输出" class="headerlink" title="2.4 计算输出"></a>2.4 计算输出</h2><p>根据输入参数和权重的乘积和值，得到当前的输出。需要注意的是：关于矩阵的乘法，注意对应的矩阵的行列数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateOutput</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""返回值是隐藏层输出和输出层输出"""</span></span><br><span class="line">    print(x)</span><br><span class="line">    b = [];</span><br><span class="line">    <span class="comment"># 遍历隐藏层结点，得到每一个隐藏层的输出</span></span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> range(hidden_nodes):</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment"># 针对该隐藏层结点，计算所有输入节点加权和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(input_nodes):</span><br><span class="line">            <span class="comment"># 输入层第i个神经元与隐藏层第h个神经元之间加权和，得到第h个神经元接收到的输入</span></span><br><span class="line">            temp += weights_input_hidden[i][h]*x[i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># b[h]为第h个神经元的输出，使用sigmoid函数,求接收到的输入与该神经元阈值的差值的sigmoid函数。</span></span><br><span class="line">        b.append(sigmoid(temp-threshold_hidden[h]))</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    y = [];</span><br><span class="line">    <span class="comment"># 遍历输出结点</span></span><br><span class="line">    <span class="keyword">for</span> o <span class="keyword">in</span> range(output_nodes):</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(hidden_nodes):</span><br><span class="line">            <span class="comment"># 使用隐藏层神经元h与输出层神经元o之间的权重与隐藏层h的输出b[h]</span></span><br><span class="line">            temp += weights_hidden_output[h][o]*b[h];</span><br><span class="line">            </span><br><span class="line">        y.append(sigmoid(temp-threshold_output[o]))</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> b,y</span><br></pre></td></tr></table></figure>
<h2 id="2-5-更新参数"><a href="#2-5-更新参数" class="headerlink" title="2.5 更新参数"></a>2.5 更新参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getGandE</span><span class="params">(x,label,b,y)</span>:</span></span><br><span class="line">    <span class="string">"""x是当前数据"""</span></span><br><span class="line"><span class="comment">#     b,y = calculateOutput(x)</span></span><br><span class="line">    <span class="comment"># 遍历输出结点，针对每一个预测输出进行计算tmp，也就是书本上的公式5.10</span></span><br><span class="line">    g = [];  </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(output_nodes):</span><br><span class="line">        <span class="comment"># 最后一个因子是本来的输出与神经网络输出的差值</span></span><br><span class="line">        temp = y[j]*(<span class="number">1</span>-y[j])*(label-y[j])</span><br><span class="line">        g.append(temp)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#     print(g)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 书本上公式5.15</span></span><br><span class="line">    e = []</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> range(hidden_nodes):</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(output_nodes):</span><br><span class="line">            <span class="comment"># 隐藏层与输出层之间的权重与g的乘积进行累加。</span></span><br><span class="line">            temp += weights_hidden_output[h][j]*g[j]</span><br><span class="line">        e.append( b[h]*(<span class="number">1</span>-b[h])*temp)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#更新隐藏层和输出层之间的权重</span></span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> range(hidden_nodes):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(output_nodes):</span><br><span class="line">            weights_hidden_output[h][j] += learning_rate*g[j]*b[h]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新输出层的阈值</span></span><br><span class="line">    <span class="keyword">for</span>  j <span class="keyword">in</span> range(output_nodes):</span><br><span class="line">        threshold_output[j] += -learning_rate*g[j]</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 更新输入层与隐藏层之间的权重</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(input_nodes):</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(hidden_nodes):</span><br><span class="line">            weights_input_hidden[i][h] += learning_rate*e[h]*x[i]</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 更新隐藏层的阈值</span></span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> range(hidden_nodes):</span><br><span class="line">        threshold_hidden[h]+= -learning_rate*e[h]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># getGandE(x,1)</span></span><br><span class="line"><span class="comment"># print(weights_hidden_output)</span></span><br><span class="line"><span class="comment"># print(threshold_output)</span></span><br><span class="line"><span class="comment"># print(weights_input_hidden)</span></span><br><span class="line"><span class="comment"># print(threshold_hidden)</span></span><br></pre></td></tr></table></figure>
<h2 id="2-6-开始训练"><a href="#2-6-开始训练" class="headerlink" title="2.6 开始训练"></a>2.6 开始训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"train neural networks"</span>)</span><br><span class="line">    <span class="comment"># 1、获取训练数据集</span></span><br><span class="line">    dataset = pd.read_csv(open(filename), delimiter=<span class="string">","</span>)</span><br><span class="line">    dataset,labels = preprocessData(dataset)</span><br><span class="line">    trainSet,validSet = dataset[:<span class="number">15</span>],dataset[<span class="number">15</span>:]</span><br><span class="line">    trainLabel,validLabel = labels[:<span class="number">15</span>],labels[<span class="number">15</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2、初始化权重和阈值</span></span><br><span class="line">    weights_input_hidden, weights_hidden_output, threshold_hidden,  threshold_output =  getWeights()</span><br><span class="line">    </span><br><span class="line">    trainSet</span><br><span class="line"></span><br><span class="line"><span class="comment">#     print(trainSet[1:2])</span></span><br><span class="line">    epoch = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 3、开始循环</span></span><br><span class="line">    <span class="keyword">while</span> epoch&lt;<span class="number">10</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(trainSet)):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            x = np.array(trainSet[i:i+<span class="number">1</span>])</span><br><span class="line">            label = trainLabel[i]</span><br><span class="line">            <span class="comment"># 3.1 计算输出</span></span><br><span class="line">            b,y = calculateOutput(x)</span><br><span class="line">            <span class="comment"># 3.2 计算g，e并更新参数</span></span><br><span class="line">            getGandE(x,label,b,y)</span><br><span class="line">        epoch+=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="2-7-计算误差"><a href="#2-7-计算误差" class="headerlink" title="2.7 计算误差"></a>2.7 计算误差</h2><p>标准BP算法每次更新只针对单个样例，参数更新的非常频繁，而且对不同样例进行更新的效果可能出现“抵消“现象。因此，为了达到同样的累积误差极小值，标准BP算法往往需要进行更多次数的迭代。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算单个数据的误差</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateLoss</span><span class="params">(y,label)</span>:</span></span><br><span class="line">    loss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(output_nodes):</span><br><span class="line">        loss += (y[j]-label[j])**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有数据的误差</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateAllLoss</span><span class="params">(dataset,y,labels)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range (len(dataset)):</span><br><span class="line">        loss = calculateLoss(y[k],labels[k])</span><br><span class="line">        lossAll.append(loss)</span><br><span class="line">    </span><br><span class="line">    self.lossAverage = sum(lossAll)/len(dataset)</span><br></pre></td></tr></table></figure>
<h1 id="3-合并代码"><a href="#3-合并代码" class="headerlink" title="3 合并代码"></a>3 合并代码</h1><p>将以上代码整合起来，写成一个类。合并之后的代码如下，英文注释是重写代码之后加上的，中文注释是上文写代码时使用的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">FILENAME = <span class="string">"C:/Users/14259/Desktop/25周/watermelon.csv"</span></span><br><span class="line">OUTPUT_NODES = <span class="number">1</span></span><br><span class="line">HIDDEN_NODES = <span class="number">10</span></span><br><span class="line">LEARNING_RATE = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BP</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    标准BP算法</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hidden_nodes, output_nodes, learning_rate, filename, input_nodes=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param hidden_nodes:</span></span><br><span class="line"><span class="string">        :param output_nodes:</span></span><br><span class="line"><span class="string">        :param learning_rate:</span></span><br><span class="line"><span class="string">        :param filename: the path of dataset</span></span><br><span class="line"><span class="string">        :param input_nods: 输入节点需要在知道数据集的情况下确定，因此初始化的时候可以不用管</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.options = &#123;&#125;</span><br><span class="line">        self.options[<span class="string">'input_nodes'</span>] = input_nodes</span><br><span class="line">        self.options[<span class="string">'output_nodes'</span>] = output_nodes</span><br><span class="line">        self.options[<span class="string">'hidden_nodes'</span>] = hidden_nodes</span><br><span class="line">        self.options[<span class="string">'learning_rate'</span>] = learning_rate</span><br><span class="line">        self.dataset = pd.read_csv(open(filename), delimiter=<span class="string">","</span>)    <span class="comment"># the raw data</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># the train dataset and validation dataset</span></span><br><span class="line">        self.data = &#123;&#125;</span><br><span class="line">        self.label = &#123;&#125;</span><br><span class="line">        self.data[<span class="string">'train'</span>] = <span class="literal">None</span></span><br><span class="line">        self.data[<span class="string">'valid'</span>] = <span class="literal">None</span>   <span class="comment"># the validation set</span></span><br><span class="line">        self.label[<span class="string">'train'</span>] = <span class="literal">None</span></span><br><span class="line">        self.label[<span class="string">'valid'</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># the weights and threshold</span></span><br><span class="line">        self.weights = &#123;&#125;</span><br><span class="line">        self.threshold = &#123;&#125;</span><br><span class="line">        self.weights[<span class="string">'input_hidden'</span>] = <span class="literal">None</span></span><br><span class="line">        self.weights[<span class="string">'hidden_output'</span>] = <span class="literal">None</span></span><br><span class="line">        self.threshold[<span class="string">'hidden'</span>] = <span class="literal">None</span></span><br><span class="line">        self.threshold[<span class="string">'output'</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># the output value of neural</span></span><br><span class="line">        self.output = &#123;&#125;</span><br><span class="line">        self.output[<span class="string">'b'</span>] = <span class="literal">None</span>  <span class="comment"># the hidden layer output</span></span><br><span class="line">        self.output[<span class="string">'y'</span>] = <span class="literal">None</span>  <span class="comment"># the output layer output</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># the gradient of output neuron and hidden neuron</span></span><br><span class="line">        self.gradient = &#123;&#125;</span><br><span class="line">        self.gradient[<span class="string">'output'</span>] = <span class="literal">None</span></span><br><span class="line">        self.gradient[<span class="string">'hidden'</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_preprocess_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        数据预处理，</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ds = self.dataset</span><br><span class="line"></span><br><span class="line">        <span class="comment"># delete the useless attr columns, the number column here.</span></span><br><span class="line">        x = [<span class="number">0</span>]</span><br><span class="line">        ds.drop(ds.columns[x], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># transfer the chinese into 1 or 0 for programming</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ds.iloc[:, <span class="number">-1</span>])):</span><br><span class="line">            <span class="comment"># ds.iloc[:, -1]is the method to get the last column</span></span><br><span class="line">            <span class="keyword">if</span> ds.iloc[:, <span class="number">-1</span>][i].strip() == <span class="string">'是'</span>:</span><br><span class="line">                temp.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp.append(<span class="number">0</span>)</span><br><span class="line">        ds.iloc[:, <span class="number">-1</span>] = temp</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get the labels column</span></span><br><span class="line">        labels = ds[ds.columns[<span class="number">-1</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># delete the lables column</span></span><br><span class="line">        x = [<span class="number">8</span>]</span><br><span class="line">        ds.drop(ds.columns[x], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">        columns = ds.columns[<span class="number">0</span>:<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment"># use the ont-hot to encoding the dataset</span></span><br><span class="line">        ds = pd.get_dummies(ds, columns=columns);</span><br><span class="line"></span><br><span class="line">        <span class="comment"># set the number of input node</span></span><br><span class="line">        self.options[<span class="string">'input_nodes'</span>] = ds.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ds, labels</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">split_dataset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        split the dataset into training dataset and validation dataset</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ds, labels = self._preprocess_data()</span><br><span class="line">        train_set, valid_set = ds[:<span class="number">12</span>], ds[<span class="number">12</span>:]</span><br><span class="line">        train_label, valid_label = labels[:<span class="number">12</span>], labels[<span class="number">12</span>:]</span><br><span class="line"></span><br><span class="line">        self.data[<span class="string">'train'</span>] = train_set</span><br><span class="line">        self.data[<span class="string">'valid'</span>] = valid_set</span><br><span class="line">        self.label[<span class="string">'train'</span>] = train_label</span><br><span class="line">        self.label[<span class="string">'valid'</span>] = valid_label.reset_index(drop=<span class="literal">True</span>)  <span class="comment"># 重新建立索引</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(self, inx)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        the activation function</span></span><br><span class="line"><span class="string">        :param inx: the independent variable inx</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1.0</span> + math.exp(-inx))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_weight</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        init weights and threshold of the neural in the range 0-1.</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        weights_input_hidden = np.random.sample((self.options[<span class="string">'input_nodes'</span>], self.options[<span class="string">'hidden_nodes'</span>]))</span><br><span class="line">        weights_hidden_output = np.random.sample((self.options[<span class="string">'hidden_nodes'</span>], self.options[<span class="string">'output_nodes'</span>]))</span><br><span class="line"></span><br><span class="line">        threshold_hidden = np.random.random(self.options[<span class="string">'hidden_nodes'</span>])</span><br><span class="line">        threshold_output = np.random.random(self.options[<span class="string">'output_nodes'</span>])</span><br><span class="line"></span><br><span class="line">        self.weights[<span class="string">'input_hidden'</span>],self.weights[<span class="string">'hidden_output'</span>] = weights_input_hidden, weights_hidden_output</span><br><span class="line">        self.threshold[<span class="string">'hidden'</span>], self.threshold[<span class="string">'output'</span>] = threshold_hidden, threshold_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_output</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        calculate the output of hidden layer and output layer</span></span><br><span class="line"><span class="string">        :param x: the input value, its dimension is the input_nodes*1.</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        b = [];</span><br><span class="line">        <span class="comment"># 遍历隐藏层结点，得到每一个隐藏层的输出</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(self.options[<span class="string">'hidden_nodes'</span>]):</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">            <span class="comment"># 针对该隐藏层结点，计算所有输入节点加权和</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.options[<span class="string">'input_nodes'</span>]):</span><br><span class="line">                <span class="comment"># 输入层第i个神经元与隐藏层第h个神经元之间加权和，得到第h个神经元接收到的输入</span></span><br><span class="line">                temp += self.weights[<span class="string">'input_hidden'</span>][i][h] * x[i]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># b[h]为第h个神经元的输出，使用sigmoid函数,求接收到的输入与该神经元阈值的差值的sigmoid函数。</span></span><br><span class="line">            b.append(self.sigmoid(temp - self.threshold[<span class="string">'hidden'</span>][h]))</span><br><span class="line"></span><br><span class="line">        y = [];</span><br><span class="line">        <span class="comment"># 遍历输出结点</span></span><br><span class="line">        <span class="keyword">for</span> o <span class="keyword">in</span> range(self.options[<span class="string">'output_nodes'</span>]):</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> h <span class="keyword">in</span> range(self.options[<span class="string">'hidden_nodes'</span>]):</span><br><span class="line">                <span class="comment"># 使用隐藏层神经元h与输出层神经元o之间的权重与隐藏层h的输出b[h]</span></span><br><span class="line">                temp += self.weights[<span class="string">'hidden_output'</span>][h][o] * b[h];</span><br><span class="line"></span><br><span class="line">            y.append(self.sigmoid(temp - self.threshold[<span class="string">'output'</span>][o]))</span><br><span class="line"></span><br><span class="line">        self.output[<span class="string">'b'</span>] = b</span><br><span class="line">        self.output[<span class="string">'y'</span>] = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span><span class="params">(self, x, label)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        get the gradient of the output neuron and hidden neuron</span></span><br><span class="line"><span class="string">        :param label:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 遍历输出结点，针对每一个预测输出进行计算tmp，也就是书本上的公式5.10</span></span><br><span class="line">        y = self.output[<span class="string">'y'</span>]</span><br><span class="line">        g = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(self.options[<span class="string">'output_nodes'</span>]):</span><br><span class="line">            <span class="comment"># 最后一个因子是本来的输出与神经网络输出的差值</span></span><br><span class="line">            temp = y[j] * (<span class="number">1</span> - y[j]) * (label - y[j])</span><br><span class="line">            g.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#     print(g)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 书本上公式5.15</span></span><br><span class="line">        b = self.output[<span class="string">'b'</span>]</span><br><span class="line">        e = []</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(self.options[<span class="string">'hidden_nodes'</span>]):</span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.options[<span class="string">'output_nodes'</span>]):</span><br><span class="line">                <span class="comment"># 隐藏层与输出层之间的权重与g的乘积进行累加。</span></span><br><span class="line">                temp += self.weights[<span class="string">'hidden_output'</span>][h][j] * g[j]</span><br><span class="line">            e.append(b[h] * (<span class="number">1</span> - b[h]) * temp)</span><br><span class="line"></span><br><span class="line">        self.gradient[<span class="string">'output'</span>], self.gradient[<span class="string">'hidden'</span>] = g, e</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_weight_and_threshold</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        update the weights and threholds</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 更新隐藏层和输出层之间的权重</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(self.options[<span class="string">'hidden_nodes'</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.options[<span class="string">'output_nodes'</span>]):</span><br><span class="line">                self.weights[<span class="string">'hidden_output'</span>][h][j] += self.options[<span class="string">'learning_rate'</span>] * self.gradient[<span class="string">'output'</span>][j] * self.output[<span class="string">'b'</span>][h]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新输出层的阈值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(self.options[<span class="string">'output_nodes'</span>]):</span><br><span class="line">            self.threshold[<span class="string">'output'</span>][j] += -self.options[<span class="string">'learning_rate'</span>] * self.gradient[<span class="string">'output'</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新输入层与隐藏层之间的权重</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.options[<span class="string">'input_nodes'</span>]):</span><br><span class="line">            <span class="keyword">for</span> h <span class="keyword">in</span> range(self.options[<span class="string">'hidden_nodes'</span>]):</span><br><span class="line">                self.weights[<span class="string">'input_hidden'</span>][i][h] += self.options[<span class="string">'learning_rate'</span>] * self.gradient[<span class="string">'hidden'</span>][h] * x[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新隐藏层的阈值</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(self.options[<span class="string">'hidden_nodes'</span>]):</span><br><span class="line">            self.threshold[<span class="string">'hidden'</span>][h] += -self.options[<span class="string">'learning_rate'</span>] * self.gradient[<span class="string">'hidden'</span>][h]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_weight_and_threshold</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># print("weights between input and hidden is")</span></span><br><span class="line">        <span class="comment"># print(self.weights['input_hidden'])</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">'output of output layer'</span>)</span><br><span class="line">        print(self.output[<span class="string">'y'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_loss</span><span class="params">(self, labels)</span>:</span></span><br><span class="line">        loss = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.options[<span class="string">'output_nodes'</span>]):</span><br><span class="line">            loss += (self.output[<span class="string">'y'</span>][i]-labels[i])**<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">graph</span><span class="params">(self, train_loss, valid_loss)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        graph the loss</span></span><br><span class="line"><span class="string">        :param train_loss:</span></span><br><span class="line"><span class="string">        :param valid_loss:</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">        plt.ylabel(<span class="string">'loss'</span>)</span><br><span class="line">        x = range(<span class="number">3000</span>)</span><br><span class="line">        plt.scatter(x, train_loss, c=<span class="string">'red'</span>)</span><br><span class="line">        plt.scatter(x, valid_loss, c=<span class="string">'green'</span>)</span><br><span class="line">        plt.grid(<span class="literal">True</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># preprocess data and split dataset</span></span><br><span class="line">        self.split_dataset()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># initialize weights and threshold</span></span><br><span class="line">        self.init_weight()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># begin to cycle</span></span><br><span class="line">        epoch = <span class="number">0</span></span><br><span class="line">        train_loss_list = []</span><br><span class="line">        valid_loss_list = []</span><br><span class="line">        <span class="keyword">while</span> epoch &lt; <span class="number">3000</span>:</span><br><span class="line">            train_loss = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.data[<span class="string">'train'</span>])):</span><br><span class="line">                x = np.array(self.data[<span class="string">'train'</span>][i:i + <span class="number">1</span>])</span><br><span class="line">                label = self.label[<span class="string">'train'</span>][i]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># calculate output of output layer and hidden layer</span></span><br><span class="line">                self.calculate_output(*x)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># get gredient</span></span><br><span class="line">                self.get_gradient(*x, label)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># update weights and threshold</span></span><br><span class="line">                self.update_weight_and_threshold(*x)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># print(label)</span></span><br><span class="line">                loss = self.calculate_loss([label])</span><br><span class="line">                train_loss += loss</span><br><span class="line">            train_loss /= len(self.data[<span class="string">'train'</span>])</span><br><span class="line">            train_loss_list.append(train_loss)</span><br><span class="line">            <span class="comment"># print("train_loss: %.5f" % train_loss)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            valid_loss = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.data[<span class="string">'valid'</span>])):</span><br><span class="line">                x = np.array(self.data[<span class="string">'valid'</span>][i:i + <span class="number">1</span>])</span><br><span class="line">                <span class="comment"># print(self.label['valid'])</span></span><br><span class="line">                label = self.label[<span class="string">'valid'</span>][i]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># calculate output of output layer and hidden layer</span></span><br><span class="line">                self.calculate_output(*x)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># get gredient</span></span><br><span class="line">                self.get_gradient(*x, label)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># update weights and threshold</span></span><br><span class="line">                self.update_weight_and_threshold(*x)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># print(label)</span></span><br><span class="line">                loss = self.calculate_loss([label])</span><br><span class="line">                valid_loss += loss</span><br><span class="line">            valid_loss /= len(self.data[<span class="string">'train'</span>])</span><br><span class="line">            valid_loss_list.append(valid_loss)</span><br><span class="line">            <span class="comment"># print("valid_loss: %.5f" % valid_loss)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># self.print_weight_and_threshold()</span></span><br><span class="line">            epoch += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> epoch %<span class="number">100</span>== <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"traing %d times"</span> % epoch)</span><br><span class="line">        self.graph(train_loss_list, valid_loss_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># create an BP object</span></span><br><span class="line">    print(<span class="string">"start training..."</span>)</span><br><span class="line">    bp = BP(HIDDEN_NODES, OUTPUT_NODES, LEARNING_RATE, FILENAME)</span><br><span class="line">    bp.train()</span><br></pre></td></tr></table></figure>
<p>上面代码运行之后得到的图形如下图所示：<br><img src="/images/DataMiningTheory/BP/BP_02.png" width="400px" height="400px"></p>
<p>其中红色的先表示训练误差，绿色的线表示验证误差（这里没有说错）。至于为什么训练误差还会出现增大的情况，目前原因不是很清楚。思考可能的原因，如下：</p>
<ul>
<li>数据集不够。因为使用的是书本上提供的数据集，共17条，训练集11条，验证集6条。</li>
<li>采用的标准BP算法，每一条数据都会对应的修改参数，从而可能存在抵消情况</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/15/MachineLearningAndDataMining/标准BP算法Python实现/" data-id="cjtinfpsf005gxw77jmkgoskn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BP算法/">BP算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/java基础知识系列（三）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/10/java/java基础知识系列（三）/" class="article-date">
  <time datetime="2018-08-10T08:54:29.000Z" itemprop="datePublished">2018-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/10/java/java基础知识系列（三）/">java基础系列知识——collections</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java基础系列知识——collections"><a href="#java基础系列知识——collections" class="headerlink" title="java基础系列知识——collections"></a>java基础系列知识——collections</h1><p>主要是自己在写java代码过程中使用到的一些java集合的相关内容。</p>
<h1 id="1-Map"><a href="#1-Map" class="headerlink" title="1 Map"></a>1 Map</h1><h2 id="1-1-TreeMap"><a href="#1-1-TreeMap" class="headerlink" title="1.1 TreeMap"></a>1.1 TreeMap</h2><p>TreeMap的默认排序规则：按照key的字典顺序来进行升序。<br>下面的代码是，通过输入n对数字，每一对数字是key value组成，将key值一样的value进行求和，然后根据key值排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;Integer,Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> key = scan.nextInt();</span><br><span class="line">    <span class="keyword">int</span> value = scan.nextInt();</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">        map.put(key, value+map.get(key));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Integer i:map.keySet())&#123;</span><br><span class="line">    System.out.println(i+<span class="string">" "</span>+map.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-2-HashMap"><a href="#1-2-HashMap" class="headerlink" title="1.2 HashMap"></a>1.2 HashMap</h2><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 在HashMap中通过get()来获取value，通过put()来插入value，ContainsKey()用来检验对象是否已经存在。LinkedHashMap保存了记录的插入顺序，在使用Iterator遍历的时候，保证了元素迭代的顺序。而HashMap遍历的时候获取的数据完全是随机的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,String&gt; hm = <span class="keyword">new</span> LinkedHashMap&lt;String,String&gt;();</span><br></pre></td></tr></table></figure></p>
<h1 id="2-Set"><a href="#2-Set" class="headerlink" title="2 Set"></a>2 Set</h1><h2 id="2-1-TreeSet"><a href="#2-1-TreeSet" class="headerlink" title="2.1 TreeSet"></a>2.1 TreeSet</h2><p>TreeSet可用于对象元素的排序的，同时保证元素唯一。<br>下面的代码是随机输入n个数字，然后对着n个数字进行去重，然后排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line"><span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    temp[i] = scan.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始去重和排序,使用TreeSet</span></span><br><span class="line">TreeSet&lt;Integer&gt; ts = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(Integer j:temp)&#123;</span><br><span class="line">    ts.add(j);</span><br><span class="line">&#125;</span><br><span class="line">Iterator iter = ts.iterator();   <span class="comment">//数据遍历</span></span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;			</span><br><span class="line">    System.out.println(iter.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将上面的ts转换为字符串数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] res = (String[])ts.toArray(<span class="keyword">new</span> String[ts.size()])</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/10/java/java基础知识系列（三）/" data-id="cjtinfppa0010xw77d5opp8xu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/collections/">collections</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/java基础知识系列（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/10/java/java基础知识系列（二）/" class="article-date">
  <time datetime="2018-08-10T08:42:50.000Z" itemprop="datePublished">2018-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/10/java/java基础知识系列（二）/">java基础知识系列——demo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文主要是关于java算法练习过程中，遇到的一些不错的解决思路，整理下来。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="求质数的因子"><a href="#求质数的因子" class="headerlink" title="求质数的因子"></a>求质数的因子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数x是要求的数，返回的res是因子，中间以空格分隔开</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getResult</span><span class="params">(<span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    String res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;x;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//此时说明该数是它的一个因子</span></span><br><span class="line">            x = x/i;</span><br><span class="line">            res += i+<span class="string">" "</span>;</span><br><span class="line">            i = <span class="number">1</span>;   <span class="comment">//i要重置为2</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最好找不到除数的时候，剩下的数就是质因子了。</span></span><br><span class="line">    res += x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将数逆序输出并使它不重复"><a href="#将数逆序输出并使它不重复" class="headerlink" title="将数逆序输出并使它不重复"></a>将数逆序输出并使它不重复</h2><p>通过将数逆序输出，同时重复的不输出。如果是400200，那么输出的是24，当然如果想输出024，可以判断一下原始数据的最后一位数，然后决定输出结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如输入 786884  则输出 4867</span></span><br><span class="line"><span class="comment">//经典之处在于，通过一个数组来记录该数字是否已经出现过，从而筛选输出的结果。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getUnrepeatedInteger</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[x%<span class="number">10</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//判断x的最低位是否已经出现过</span></span><br><span class="line">            a[x%<span class="number">10</span>]++;</span><br><span class="line">            num = num*<span class="number">10</span>+(x%<span class="number">10</span>);	</span><br><span class="line">        &#125;</span><br><span class="line">        x = x/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure></p>
<h2 id="判断字符串中是否含有长度超过2的相同子串"><a href="#判断字符串中是否含有长度超过2的相同子串" class="headerlink" title="判断字符串中是否含有长度超过2的相同子串"></a>判断字符串中是否含有长度超过2的相同子串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否包含相同子串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length()-<span class="number">2</span>;i++)&#123;</span><br><span class="line">	String substring = s.substring(i,i+<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span>(s.substring(i+<span class="number">1</span>).contains(substring))&#123;</span><br><span class="line">		<span class="comment">//判断该子串之后的字符串中是否包含相同的子串即可</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-将列表中的元素进行合并"><a href="#2-4-将列表中的元素进行合并" class="headerlink" title="2.4 将列表中的元素进行合并"></a>2.4 将列表中的元素进行合并</h2><p>比如有(1,2) (2,3), (4,5), (3,1), 那么合并之后应该只有 (1,2,3) (4,5)这两项。<br>思路就是，每次合并一个之后就重新循环，避免索引出问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> k = l.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;l.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;l.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasSameValue(l.get(i),l.get(j)))&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">int</span>[] temp = changeToInt(combineArray(l.get(i), l.get(j)));</span><br><span class="line">                l.add(temp);</span><br><span class="line">                l.remove(j);</span><br><span class="line">                l.remove(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k == l.size())&#123;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/10/java/java基础知识系列（二）/" data-id="cjtinfppe0016xw7778xwsiba" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/realize/">realize</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/java基础知识系列（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/10/java/java基础知识系列（一）/" class="article-date">
  <time datetime="2018-08-10T08:41:29.000Z" itemprop="datePublished">2018-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/10/java/java基础知识系列（一）/">java基础系列知识——Snippets</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java基础系列知识——Snippets"><a href="#java基础系列知识——Snippets" class="headerlink" title="java基础系列知识——Snippets"></a>java基础系列知识——Snippets</h1><p>主要是java编程中遇到的一些小的问题收集，便于之后进行查阅</p>
<h2 id="1-小demo"><a href="#1-小demo" class="headerlink" title="1 小demo"></a>1 小demo</h2><h3 id="1-1-split"><a href="#1-1-split" class="headerlink" title="1.1 split"></a>1.1 split</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意： . 、 | 和 * 等转义字符，必须得加 \\。</span></span><br><span class="line"><span class="comment">// 注意：多个分隔符，可以用 | 作为连字符。</span></span><br><span class="line">String[] s = temp.split(<span class="string">"\\."</span>); <span class="comment">//在以“.”作为切分的符号时，注意转义</span></span><br><span class="line">String[] sr = s.split(<span class="string">"\\s+"</span>);    <span class="comment">//匹配多个空格的时候</span></span><br><span class="line">String temp = <span class="string">"a and b or c"</span>;</span><br><span class="line">String[] s = temp.split(<span class="string">"and|or"</span>)</span><br><span class="line"><span class="comment">//输出结果为  a  b  c</span></span><br><span class="line">String s = <span class="string">"E:\\abc\\def\\fgj\\re.txt"</span>;</span><br><span class="line">String[] s = s.split(<span class="string">"\\\\"</span>);   <span class="comment">//注意文件路径时如何进行分割</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-进制转换"><a href="#1-2-进制转换" class="headerlink" title="1.2 进制转换"></a>1.2 进制转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 十六进制、八进制、二进制转换成十进制，使用Integer.parseInt(number, base)</span></span><br><span class="line"><span class="keyword">int</span> x = Integer.parseInt(s,<span class="number">2</span>)    <span class="comment">//此时说明s是二进制的格式，转换成10进制，存储在x中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//十进制转换成十六进制、八进制、二进制</span></span><br><span class="line">Integer s = (Integer)scan.nextInt();    <span class="comment">//s需要是Integer类型，而不能是int</span></span><br><span class="line">String a = s.toHexString(s);</span><br><span class="line">String b = s.toBinaryString(s);   <span class="comment">//转化成2进制</span></span><br><span class="line">String c = s.toOctalString(s);   <span class="comment">//转换成8进制。</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-获取字符串中的第一个字符"><a href="#1-3-获取字符串中的第一个字符" class="headerlink" title="1.3 获取字符串中的第一个字符"></a>1.3 获取字符串中的第一个字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = s.charAt(<span class="number">0</span>)   <span class="comment">//使用charAt()方法获取指定索引位置的字符</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-字符的ASCII编码"><a href="#1-4-字符的ASCII编码" class="headerlink" title="1.4 字符的ASCII编码"></a>1.4 字符的ASCII编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">int</span> a = (<span class="keyword">int</span>)c;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-字符数组转换成字符串"><a href="#1-5-字符数组转换成字符串" class="headerlink" title="1.5 字符数组转换成字符串"></a>1.5 字符数组转换成字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c是字符数组</span></span><br><span class="line">String s = <span class="keyword">new</span> String(c);</span><br></pre></td></tr></table></figure>
<h3 id="1-6-将数组按照字典进行排序，直接使用sort"><a href="#1-6-将数组按照字典进行排序，直接使用sort" class="headerlink" title="1.6 将数组按照字典进行排序，直接使用sort()"></a>1.6 将数组按照字典进行排序，直接使用sort()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s是要进行排序的数组，不用返回值。</span></span><br><span class="line">Arrays.sort(s);</span><br></pre></td></tr></table></figure>
<h3 id="1-7-数值类型和字符串相互转换"><a href="#1-7-数值类型和字符串相互转换" class="headerlink" title="1.7 数值类型和字符串相互转换"></a>1.7 数值类型和字符串相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = Integer.parseInt(<span class="string">"123"</span>)</span><br><span class="line"><span class="keyword">double</span> doubleNum = Double.parseDouble(<span class="string">"1.23"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值类型转换成string</span></span><br><span class="line">String s = Integer.toString(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<h3 id="1-8-substring"><a href="#1-8-substring" class="headerlink" title="1.8 substring"></a>1.8 substring</h3><p>public String substring(int beginIndex[, int endIndex])返回字符串的子字符串，beginIndex是起始索引（包括），endIndex是结束索引（不包括）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"WWW.baidu.com"</span>;</span><br><span class="line">s.substring(<span class="number">3</span>);   <span class="comment">//baidu.com</span></span><br><span class="line">s.substring(<span class="number">3</span>,<span class="number">9</span>);  <span class="comment">//baidu</span></span><br></pre></td></tr></table></figure></p>
<h3 id="1-9-数组初始化"><a href="#1-9-数组初始化" class="headerlink" title="1.9 数组初始化"></a>1.9 数组初始化</h3><p>静态初始化和动态初始化：</p>
<ul>
<li>一维数组</li>
<li>二维数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维数组  静态初始化</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一维数组  动态初始化</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组静态初始化</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/10/java/java基础知识系列（一）/" data-id="cjtinfpp7000sxw77pp4fczvy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/小demo/">小demo</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C语言/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MachineLearning/">MachineLearning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kaggle/">kaggle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python3/">python3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/weibo/">weibo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/word2vec/">word2vec</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据挖掘/">数据挖掘</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BP算法/">BP算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bayes/">Bayes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C语言/">C语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DL/">DL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EM/">EM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KNN/">KNN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MachineLearning/">MachineLearning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NLP/">NLP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPSS/">SPSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/beautifulsoup/">beautifulsoup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/collections/">collections</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/divide-and-conquer/">divide-and-conquer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/file/">file</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jieba/">jieba</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k-means/">k-means</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kaggle/">kaggle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/matplotlib/">matplotlib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/numpy/">numpy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pandas/">pandas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-爬虫/">python 爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python3/">python3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/realize/">realize</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/requests/">requests</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sklearn/">sklearn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/snippets/">snippets</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weibo/">weibo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wiebo/">wiebo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/word2vec/">word2vec</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/全概率公式/">全概率公式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/决策树/">决策树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分类/">分类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小demo/">小demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微博/">微博</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/支持向量机/">支持向量机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据分析/">数据分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/时间复杂度/">时间复杂度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最大似然估计/">最大似然估计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/贝叶斯/">贝叶斯</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 17.5px;">Algorithm</a> <a href="/tags/BP算法/" style="font-size: 10px;">BP算法</a> <a href="/tags/Bayes/" style="font-size: 10px;">Bayes</a> <a href="/tags/C语言/" style="font-size: 10px;">C语言</a> <a href="/tags/DL/" style="font-size: 10px;">DL</a> <a href="/tags/EM/" style="font-size: 10px;">EM</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/KNN/" style="font-size: 10px;">KNN</a> <a href="/tags/MachineLearning/" style="font-size: 12.5px;">MachineLearning</a> <a href="/tags/NLP/" style="font-size: 10px;">NLP</a> <a href="/tags/SPSS/" style="font-size: 10px;">SPSS</a> <a href="/tags/beautifulsoup/" style="font-size: 10px;">beautifulsoup</a> <a href="/tags/collections/" style="font-size: 10px;">collections</a> <a href="/tags/divide-and-conquer/" style="font-size: 10px;">divide-and-conquer</a> <a href="/tags/file/" style="font-size: 10px;">file</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/jieba/" style="font-size: 10px;">jieba</a> <a href="/tags/k-means/" style="font-size: 10px;">k-means</a> <a href="/tags/kaggle/" style="font-size: 10px;">kaggle</a> <a href="/tags/matplotlib/" style="font-size: 12.5px;">matplotlib</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/numpy/" style="font-size: 10px;">numpy</a> <a href="/tags/pandas/" style="font-size: 10px;">pandas</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/python-爬虫/" style="font-size: 10px;">python 爬虫</a> <a href="/tags/python3/" style="font-size: 10px;">python3</a> <a href="/tags/realize/" style="font-size: 10px;">realize</a> <a href="/tags/requests/" style="font-size: 10px;">requests</a> <a href="/tags/sklearn/" style="font-size: 10px;">sklearn</a> <a href="/tags/snippets/" style="font-size: 10px;">snippets</a> <a href="/tags/weibo/" style="font-size: 10px;">weibo</a> <a href="/tags/wiebo/" style="font-size: 10px;">wiebo</a> <a href="/tags/word2vec/" style="font-size: 10px;">word2vec</a> <a href="/tags/全概率公式/" style="font-size: 10px;">全概率公式</a> <a href="/tags/决策树/" style="font-size: 10px;">决策树</a> <a href="/tags/分类/" style="font-size: 12.5px;">分类</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/字符串/" style="font-size: 10px;">字符串</a> <a href="/tags/小demo/" style="font-size: 10px;">小demo</a> <a href="/tags/工具/" style="font-size: 10px;">工具</a> <a href="/tags/微博/" style="font-size: 10px;">微博</a> <a href="/tags/支持向量机/" style="font-size: 10px;">支持向量机</a> <a href="/tags/数据分析/" style="font-size: 10px;">数据分析</a> <a href="/tags/时间复杂度/" style="font-size: 10px;">时间复杂度</a> <a href="/tags/最大似然估计/" style="font-size: 10px;">最大似然估计</a> <a href="/tags/算法/" style="font-size: 12.5px;">算法</a> <a href="/tags/贝叶斯/" style="font-size: 10px;">贝叶斯</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/11/02/Algorithms/DivideAndConquer/">Divide and Conquer</a>
          </li>
        
          <li>
            <a href="/2018/11/02/Algorithms/Dynamic-Planning/">Dynamic Planning</a>
          </li>
        
          <li>
            <a href="/2018/10/31/python3/word2vec/">word2vec</a>
          </li>
        
          <li>
            <a href="/2018/10/21/Algorithms/算法/">算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>